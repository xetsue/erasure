<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A/E Lens - Erasure</title>
    <style>
        :root {
            --bg-color: #000000;
            --frame-color: #ffffff;
            --text-color: #ffffff;
            --button-bg: #111111;
            --button-text: #ffffff;
            --settings-bg: #000000;
            --settings-outline: #555555;
            --slider-track: #555555;
            --slider-thumb: #ffffff;
            --checkbox-color: #333333;
            --frame-radius: 5px;
            --button-radius: 5px;
            --settings-radius: 3px;
            --font-family: 'Monospace', monospace;
            --number-input-bg: var(--settings-bg);
            --number-input-outline-color: var(--settings-outline);
            --frame-custom-size: 400px;
            --frame-custom-min-size: 300px;
            --glass-bg: rgba(20, 20, 20, 0.9);
            --compare-active-bg: #ffffff;
            --compare-active-text: #000000;
            --accent-color: #00ff9d;
            --desc-bg: #111111;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow-y: auto;
            transition: background-color 0.3s, color 0.3s;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid var(--settings-outline);
            flex-shrink: 0;            
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header-branding {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: center;
            border-left: 1px solid var(--settings-outline);
            padding-left: 15px;
            margin-left: auto;
        }

        .brand-main {
            font-weight: bold;
            line-height: 1;
        }

        .brand-sub {
            font-size: 0.8em;
            opacity: 0.7;
            line-height: 1;
            margin-top: 4px;
        }

        .ascii-frame {
            background-color: var(--button-bg);
            color: var(--button-text);
            border: 1px solid var(--frame-color);
            padding: 8px 1px;
            font-family: var(--font-family);
            border-radius: var(--button-radius);
            font-size: 14px;
            min-width: 60px;
            text-align: center;
            white-space: pre;
            cursor: default;
            transition: all 0.3s;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            flex-grow: 1;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px;
            width: 100%;
            height: calc(100vh - 60px); 
        }

        .left-panel-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 100%;
            flex-shrink: 0;
            transition: width 0.3s, height 0.3s;
            position: relative;
            overflow-x: hidden;
        }

        .frame {
            border: 1.6px solid var(--frame-color);
            border-radius: var(--frame-radius);
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            resize: both;
            aspect-ratio: 1 / 1;
            width: var(--frame-custom-size, 90vmin);
            height: var(--frame-custom-size, 90vmin);
            min-width: var(--frame-custom-min-size);
            min-height: var(--frame-custom-min-size);
            max-width: 100%;
            max-height: 80vh;
            background-color: #111;
            overflow: hidden;
            user-select: none;
            transition: height 0.3s;
            touch-action: none; 
        }

        .frame.fullscreen-active {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            margin: 0 !important;
            padding: 0 !important;
            border: none !important;
            resize: none !important;
            z-index: 9999 !important;
            background-color: #000 !important;
        }
        
        .frame.fullscreen-active .fs-tool-overlay { display: block; }

        .frame.processing .action-buttons,
        .frame.processing .fullscreen-btn {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            background-color: #050505;
            transform-origin: center center;
        }
        
        #original-image, #main-image, #mask-canvas, #preview-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            max-width: none;
            max-height: none;
            pointer-events: none;
            transform-origin: center center;
        }
        
        #original-image { z-index: 0; display: none; }
        #main-image { z-index: 1; display: none; transition: opacity 0.1s; }
        
        #mask-canvas { 
            pointer-events: auto; 
            opacity: 0.6; 
            cursor: crosshair; 
            z-index: 20; 
            mix-blend-mode: normal; 
        }
        
        #preview-canvas { z-index: 10; }

        .status-pill {
            position: absolute;
            bottom: 15px; 
            right: 15px;
            z-index: 10001;
            background-color: #fff;
            color: #000;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: bold;
            display: none;
            font-family: var(--font-family);
            mix-blend-mode: difference;
            pointer-events: none;
            white-space: nowrap;
        }

        .results-bar {
            width: 100%;
            height: 0;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-top: 0px solid var(--frame-color);
            display: flex;
            padding: 0;
            box-sizing: border-box;
            overflow-x: auto;
            white-space: nowrap;
            gap: 10px;
            scrollbar-width: thin;
            scrollbar-color: var(--frame-color) transparent;
            transition: height 0.3s, padding 0.3s, border 0.3s;
            flex-shrink: 0;
            z-index: 50;
        }
        
        .results-bar.active {
            height: 90px;
            padding: 10px;
            border-top: 1px solid var(--frame-color);
        }
        
        .result-thumb {
            display: inline-block;
            height: 100%;
            aspect-ratio: 1/1;
            border: 1px solid var(--settings-outline);
            margin-right: 5px;
            cursor: pointer;
            border-radius: 4px;
            background-size: cover;
            background-position: center;
            position: relative;
            opacity: 0.7;
            transition: all 0.2s;
        }
        .result-thumb:hover { opacity: 1; border-color: var(--frame-color); }
        .result-thumb.selected { opacity: 1; border: 2px solid var(--accent-color); }
        .result-thumb span {
            position: absolute;
            top: 2px;
            left: 2px;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 2px;
        }

        .action-buttons {
            position: absolute;
            top: 5px;
            left: 5px;
            display: flex;
            gap: 3px;
            z-index: 10005; 
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 3px;
            transition: opacity 0.3s;
            display: none;
        }

        .fullscreen-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            z-index: 10005;
            background-color: rgba(0,0,0,0.5);
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 8px;
            cursor: pointer;
        }
        
        .fs-tool-overlay {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10005;
            display: none;
        }

        .fs-tool-overlay .tool-popup {
            bottom: auto;
            top: 100%;
            margin-top: 5px;
            margin-bottom: 0;
        }
        
        .tool-selector-container { position: relative; }
        
        .tool-popup {
            position: absolute;
            left: 0;
            bottom: 100%; 
            top: auto;
            margin-bottom: 5px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--settings-outline);
            border-radius: 5px;
            padding: 5px;
            display: none;
            flex-direction: column;
            gap: 5px;
            z-index: 20000;
            width: 140px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .tool-popup button {
            width: 100%;
            text-align: left;
            border: none;
            background: none;
            color: var(--text-color);
        }
        .tool-popup button:hover { background-color: var(--settings-outline); }

        .controls {
            display: flex;
            justify-content: flex-start;
            width: 100%;
            margin-top: 10px;
            flex-wrap: wrap;
            gap: 10px;
            position: relative;
        }

        #run-ai-button, #rerun-button, #confirm-button, #run-ai-button-2, #fs-save-button, #upscale-load-preset, #upscale-export-preset {
            background-color: var(--text-color);
            color: var(--bg-color);
            font-weight: bold;
            border-color: var(--text-color);
        }
        #run-ai-button:disabled, #rerun-button:disabled, #confirm-button:disabled, #run-ai-button-2:disabled { opacity: 0.5; cursor: not-allowed; }
        
        #run-ai-button.cancel-mode, #run-ai-button-2.cancel-mode {
            background-color: #ff4444;
            border-color: #ff4444;
            color: white;
        }
        
        #rerun-button { display: none; }
        #confirm-button { display: none; background-color: var(--accent-color); color: #000; border-color: var(--accent-color); }

        button {
            background-color: var(--button-bg);
            color: var(--button-text);
            border: 1px solid var(--frame-color);
            padding: 8px 15px;
            cursor: pointer;
            font-family: var(--font-family);
            border-radius: var(--button-radius);
            transition: all 0.3s;
        }
        button:hover { opacity: 0.8; }
        button.active-tool { background-color: var(--frame-color); color: var(--bg-color); }
        button.compare-active { 
            background-color: var(--compare-active-bg) !important; 
            color: var(--compare-active-text) !important;
            border-color: var(--frame-color);
        }

        #advanced-settings-panel {
            background-color: var(--settings-bg);
            border: 1px solid var(--settings-outline);
            border-radius: var(--settings-radius);
            z-index: 10002;
            max-height: 80vh;
            width: 95vmin;
            display: flex;
            flex-direction: column;
            --header-height: 60px;
            --tab-bar-height: 50px;
            transition: background-color 0.3s;
        }

        .settings-header {
            background-color: var(--settings-bg);
            padding: 15px;
            border-bottom: 1px solid var(--settings-outline);
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: var(--header-height);
            flex-shrink: 0;
        }
        .settings-header h3 { margin: 0; }
        
        .header-controls { display: flex; gap: 8px; align-items: center; }
        .header-btn { padding: 4px 10px; font-size: 1.1em; border-radius: 3px; }

        .tab-bar {
            display: flex;
            border-bottom: 1px solid var(--settings-outline);
            background-color: var(--settings-bg);
            height: var(--tab-bar-height);
            overflow-x: auto;
            flex-shrink: 0;
        }
        .tab-link {
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            padding: 14px 20px;
            cursor: pointer;
            color: var(--text-color);
            opacity: 0.7;
            font-family: var(--font-family);
            font-size: 14px;
            flex-grow: 1;
            white-space: nowrap;
            min-width: 80px;
            text-align: center;
        }
        .tab-link.active { opacity: 1; border-bottom-color: var(--frame-color); font-weight: bold; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .settings-content-scrollable { flex-grow: 1; overflow-y: auto; padding: 15px; }
        .setting-group { margin-bottom: 25px; padding-bottom: 15px; border-bottom: 1px solid var(--settings-outline); }
        .slider-input-group { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; }
        .radio-group { display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; }
        .radio-option { display: flex; align-items: center; gap: 5px; cursor: pointer; }
        
        input[type="range"] { flex-grow: 1; height: 3px; background: var(--slider-track); -webkit-appearance: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 15px; height: 15px; background: var(--slider-thumb); border-radius: 50%; cursor: pointer;}
        input[type="number"], select, input[type="text"], input[type="color"] { background-color: var(--number-input-bg); border: 1px solid var(--number-input-outline-color); color: var(--text-color); padding: 4px; border-radius: 3px; width: 60px; }

        #loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center; flex-direction: column; z-index: 200;
        }
        .spinner {
            border: 4px solid #333; border-top: 4px solid var(--text-color); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .confirm-modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); z-index: 10005;
            display: none; justify-content: center; align-items: center;
        }
        .confirm-modal {
            background: var(--settings-bg); border: 1px solid var(--frame-color);
            padding: 20px; border-radius: var(--settings-radius); text-align: center;
            min-width: 250px;
        }
        .confirm-actions { display: flex; gap: 10px; justify-content: center; margin-top: 15px; }
        
        .main-container.side-by-side-layout {
            flex-direction: row;
            align-items: flex-start;
            justify-content: center;
            gap: 20px;
            height: calc(100vh - 60px);
            overflow: hidden;
        }
        .main-container.side-by-side-layout .left-panel-wrapper {
            flex: 1;
            width: auto;
            height: 100%;
            max-width: none;
            overflow-y: auto;
        }
        .main-container.side-by-side-layout .frame {
            width: 100%;
            height: 100%;
            max-height: none;
            aspect-ratio: auto;
        }
        .main-container.side-by-side-layout #advanced-settings-panel {
            flex: 0 0 400px;
            width: 400px;
            height: 100%;
            max-height: none;
            margin-top: 0;
            overflow-y: auto;
        }

        @media (max-width: 991px) and (orientation: portrait) {
            .main-container.side-by-side-layout { flex-direction: column; height: auto; overflow-y: auto; }
            .main-container.side-by-side-layout .left-panel-wrapper,
            .main-container.side-by-side-layout #advanced-settings-panel { width: 95vw; max-width: 500px; height: auto; }
            .main-container.side-by-side-layout .frame { aspect-ratio: 1/1; height: 90vmin; }
        }

        @media (max-width: 991px) and (orientation: landscape) {
            .main-container.side-by-side-layout {
                flex-direction: row;
                align-items: flex-start;
                height: calc(100vh - 60px);
                overflow: hidden;
            }
            .main-container.side-by-side-layout .left-panel-wrapper {
                display: flex;
                flex-direction: column;
                height: 100%;
                overflow: hidden;
            }
            .main-container.side-by-side-layout .frame {
                flex: 1;
                min-height: 0;
                height: auto;
                max-height: 80vh;
            }
            .main-container.side-by-side-layout .controls {
                flex-shrink: 0;
                overflow-y: auto;
                max-height: 45%;
                padding-bottom: 5px;
            }
            .main-container.side-by-side-layout #advanced-settings-panel {
                width: 320px;
                flex: 0 0 320px;
            }
            .tab-link {
                padding: 12px 20px;
                min-height: 48px;
            }
        }
        
        .placeholder-text {
            position: absolute;
            color: var(--settings-outline);
            pointer-events: none;
            font-size: 0.9em;
        }
        
        .desc-text {
            font-size: 0.8em;
            opacity: 0.9;
            margin-top: 6px;
            margin-bottom: 10px;
            line-height: 1.4;
            background-color: var(--desc-bg);
            padding: 10px;
            border-radius: 4px;
            border-left: 3px solid var(--settings-outline);
            display: none;
        }

        .mode-toggles {
            display: flex;
            width: 100%;
            margin-bottom: 10px;
            border: 1px solid var(--settings-outline);
            border-radius: var(--button-radius);
            overflow: hidden;
        }
        .mode-toggles button {
            flex: 1;
            border: none;
            border-radius: 0;
            background: var(--settings-bg);
            color: var(--text-color);
            opacity: 0.6;
        }
        .mode-toggles button.active {
            background: #000080;
            color: white;
            opacity: 1;
            font-weight: bold;
        }

        #magnifier {
            position: fixed;
            width: 100px;
            height: 100px;
            border: 2px solid var(--frame-color);
            border-radius: 5px;
            overflow: hidden;
            z-index: 20005;
            background-color: var(--bg-color);
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            display: none;
            transform: translate(-50%, calc(-100% - 50px));
            font-family: var(--font-family);
        }

        #magnifier-canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        #magnifier-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: red;
            pointer-events: none;
            text-shadow: 0 0 3px black;
            font-weight: bold;
            transform: translate(-50%, -50%);
        }

        .upscale-control-group {
            display: none; 
        }
        .upscale-control-group.visible {
            display: block;
        }
        
        #custom-upscale-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        #custom-upscale-actions button {
            flex: 1;
        }

        .filter-list-box {
            background-color: var(--desc-bg);
            border-left: 3px solid var(--frame-color);
            border-radius: 4px;
            padding: 10px;
            max-height: 250px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 20px;
        }
        .filter-option {
            text-align: left;
            border: none;
            background: none;
            padding: 8px;
            color: var(--text-color);
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 3px;
        }
        .filter-option:hover {
            background-color: var(--settings-outline);
        }
        .filter-option.active {
            background-color: var(--frame-color);
            color: var(--bg-color);
            font-weight: bold;
        }
        
        .filter-option:not(.active):nth-child(4n+1) { background-color: rgba(255, 255, 255, 0.03); }
        .filter-option:not(.active):nth-child(4n+2) { background-color: rgba(255, 255, 255, 0.06); }
        .filter-option:not(.active):nth-child(4n+3) { background-color: rgba(255, 255, 255, 0.09); }
        .filter-option:not(.active):nth-child(4n+4) { background-color: rgba(255, 255, 255, 0.12); }
        
        .sub-tab-bar {
            display: flex;
            border-bottom: 1px solid var(--settings-outline);
            margin-bottom: 15px;
        }
        .sub-tab-link {
            flex: 1;
            background: none;
            border: none;
            padding: 8px;
            color: var(--text-color);
            opacity: 0.6;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        .sub-tab-link.active {
            opacity: 1;
            border-bottom-color: var(--accent-color);
            font-weight: bold;
        }
        .sub-tab-content { display: none; }
        .sub-tab-content.active { display: block; }
        
        .dynamic-setting-group { display: none; }
        .dynamic-setting-group.active { display: block; }
        
        .gradient-editor {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-top: 5px;
        }
        .gradient-editor input[type="color"] {
            flex: 1;
            height: 30px;
            padding: 0;
            border: 1px solid var(--settings-outline);
        }
    </style>
</head>
<body>
    <div id="confirm-modal" class="confirm-modal-overlay">
        <div class="confirm-modal">
            <h4>Revert Image?</h4>
            <p>This will discard all edits and reset to the original file.</p>
            <div class="confirm-actions">
                <button id="modal-cancel">Cancel</button>
                <button id="modal-confirm" style="background-color: #ff4444; border-color: #ff4444;">Revert</button>
            </div>
        </div>
    </div>

    <div id="magnifier">
        <canvas id="magnifier-canvas"></canvas>
        <div id="magnifier-crosshair">+</div>
    </div>

    <div class="header">
        <div class="header-left">
            <button id="compare-button" title="Hold to Compare (Alt)" disabled>⊖</button>
            <div class="ascii-frame" id="ascii-anim">( =.=)</div>
        </div>
        <div class="header-branding">
            <div class="brand-main">A/E LENS</div>
            <div class="brand-sub">Erasure</div>
        </div>
    </div>

    <div class="main-container">
        <div class="left-panel-wrapper">
            <div class="frame">
                <div id="loading-overlay"><div class="spinner"></div></div>
                <div class="placeholder-text" id="empty-state-text">NO IMAGE LOADED</div>
                
                <div id="status-pill" class="status-pill">Ready</div>

                <div class="action-buttons" id="canvas-actions">
                    <button id="revert-button" title="Revert to Original">✖</button>
                    <button id="canvas-compare-button" title="Hold to Compare (Alt)" disabled>⊖</button>
                </div>
                
                <button id="fullscreen-button" class="fullscreen-btn">⛶</button>
                
                <div class="fs-tool-overlay">
                    <div class="tool-selector-container" id="fs-tool-selector-container">
                        <button id="fs-main-tool-button">Tool: Pan</button>
                        <div id="fs-tool-popup" class="tool-popup">
                            <button data-tool="pan">Pan (Space)</button>
                            <button data-tool="brush">Brush (B)</button>
                            <button data-tool="eraser">Eraser (E)</button>
                            <button data-tool="lasso">Lasso (L)</button>
                            <button data-tool="auto-lasso">Auto Lasso (A)</button>
                            <button data-tool="fill">Fill (F)</button>
                            <button data-tool="magic">Magic Brush</button>
                            <button data-tool="wand">Auto Select (S)</button>
                            <button data-tool="smart-mask">Mesh Lasso (M)</button>
                        </div>
                    </div>
                    <button id="fs-save-button" style="display: none;">Save Image</button>
                </div>

                <div class="canvas-container" id="canvas-container">
                    <img id="original-image" src="" alt="">
                    <img id="main-image" src="" alt="">
                    <canvas id="preview-canvas" style="display:none;"></canvas>
                    <canvas id="mask-canvas"></canvas>
                </div>

                <div class="results-bar" id="results-bar">
                </div>
            </div>

            <div class="controls">
                <button id="upload-button">Load Image</button>
                
                <div class="tool-selector-container">
                    <button id="main-tool-button">Tool: Pan</button>
                    <div id="tool-popup" class="tool-popup">
                        <button data-tool="pan">Pan (Space)</button>
                        <button data-tool="brush">Brush (B)</button>
                        <button data-tool="eraser">Eraser (E)</button>
                        <button data-tool="lasso">Lasso (L)</button>
                        <button data-tool="auto-lasso">Auto Lasso (A)</button>
                        <button data-tool="fill">Fill (F)</button>
                        <button data-tool="magic">Magic Brush</button>
                        <button data-tool="wand">Auto Select (S)</button>
                        <button data-tool="smart-mask">Mesh Lasso (M)</button>
                    </div>
                </div>

                <button id="run-ai-button" disabled>RUN PROCESS</button>
                <button id="rerun-button">RERUN</button>
                <button id="confirm-button">CONFIRM</button>
                
                <div style="border-left: 1px solid #555; padding-left: 10px;">
                     <button id="export-button">Save</button>
                     <button id="advanced-settings-button">Settings</button>
                </div>
            </div>
        </div>

        <div id="advanced-settings-panel" style="display: none;">
            <div class="settings-header">
                <h3>Settings</h3>
                <div class="header-controls">
                    <button id="undo-button" class="header-btn" title="Undo (Ctrl+Z)">&lt;</button>
                    <button id="redo-button" class="header-btn" title="Redo (Ctrl+Shift+Z)">&gt;</button>
                    <button id="theme-toggle-button" class="header-btn">月</button>
                </div>
            </div>
            
            <div class="tab-bar">
                <button class="tab-link active" data-tab="models">Process</button>
                <button class="tab-link" data-tab="brush">Brush</button>
            </div>

            <div class="settings-content-scrollable">
                <div id="tab-models" class="tab-content active">
                    <div class="setting-group">
                        <h4>Operation Mode</h4>
                        <div class="mode-toggles">
                            <button id="mode-eraser" class="active">Eraser</button>
                            <button id="mode-upscaler">Upscaler</button>
                            <button id="mode-editor">Editor</button>
                        </div>
                        
                        <div style="margin-top: 10px;" id="invert-option">
                            <label class="radio-option">
                                <input type="checkbox" id="invert-mask-check"> Invert Mask (Erase Outside)
                            </label>
                        </div>

                         <div style="margin-top: 10px; display: none;" id="debug-mode-container">
                            <label class="radio-option">
                                <input type="checkbox" id="debug-mode-check" checked> Debug Mode (Visualize Steps)
                            </label>
                        </div>
                    </div>

                    <div class="setting-group" id="inpaint-settings">
                        <h4>Eraser Logic</h4>
                        <select id="inpaint-algo" style="width: 100%; padding: 8px; margin-bottom: 5px;">
                            <option value="hybrid" selected>Hybrid (Balanced)</option>
                            <option value="linear">Linear (Lines/Edges)</option>
                            <option value="pattern">Pattern (Repetitive)</option>
                            <option value="smart_remove">Mesh (Text/Wire)</option>
                        </select>
                        <p class="desc-text" id="algo-desc" style="display:block;">Hybrid: Best for general use. Balances lines and texture.</p>

                        <div class="slider-input-group">
                            <label>Patch Size:</label>
                            <input type="range" id="patch-size" min="1" max="20" step="1" value="5">
                            <input type="number" id="patch-size-num" value="5" min="1" max="20">
                        </div>
                        
                        <div class="slider-input-group">
                            <label>Results Count:</label>
                            <input type="range" id="result-count" min="1" max="30" value="3">
                            <input type="number" id="result-count-num" value="3" min="1" max="30">
                        </div>

                         <div class="slider-input-group">
                            <label>Precision:</label>
                            <input type="range" id="search-effort" min="1" max="5" value="3">
                            <span id="search-effort-val">Med</span>
                        </div>
                        <p id="precision-desc" class="desc-text" style="display:block;">Balanced speed and accuracy. Recommended for most edits.</p>
                    </div>

                    <div class="setting-group" id="upscale-settings" style="display:none;">
                        <h4>Upscale Settings</h4>
                        <select id="upscale-algo" style="width: 100%; padding: 8px; margin-bottom: 5px;">
                            <option value="general" selected>General (Enhance)</option>
                            <option value="sharp">Sharp (Detail Focus)</option>
                            <option value="smooth">Smooth (Denoise)</option>
                            <option value="artistic">Artistic (Stylized)</option>
                            <option value="restore_color">Color Restoration</option>
                            <option value="custom">Custom (Manual)</option>
                        </select>
                        <p class="desc-text" id="upscale-algo-desc" style="display:block;">General: Balanced enhancement, clarity, and denoising. Best for most images.</p>
                        
                        <div style="margin-bottom: 15px;">
                            <label class="radio-option"><input type="checkbox" id="upscale-aa" checked> Anti-aliasing</label>
                        </div>

                        <div id="upscale-standard-actions">
                             <button id="run-ai-button-2" style="width: 100%; margin-bottom: 20px;">RUN PROCESS</button>
                        </div>
                        
                        <div id="custom-upscale-actions" style="display: none;">
                             <button id="upscale-load-preset">Load JSON</button>
                             <button id="upscale-export-preset">Export JSON</button>
                             <input type="file" id="upscale-preset-input" accept=".json" style="display: none;">
                        </div>

                        <div class="slider-input-group" style="margin-top: 20px;">
                            <label for="upscale-scale">Target Scale:</label>
                            <input type="range" id="upscale-scale" min="1.0" max="4.0" step="0.5" value="1.0">
                            <span id="upscale-scale-val">1.0x</span>
                        </div>
                        
                        <div id="upscale-custom-options-container" style="display: none; margin-bottom: 20px; border-bottom: 1px solid var(--settings-outline); padding-bottom: 10px;">
                             <div class="radio-group">
                                 <label class="radio-option"><input type="checkbox" id="upscale-experimental"> Experimental</label>
                                 <label class="radio-option"><input type="checkbox" id="upscale-pseudo"> Pseudo-inverted Filter</label>
                                 <label class="radio-option"><input type="checkbox" id="upscale-wiener"> Wiener Pass</label>
                             </div>
                             <br>
                             <label>Edge Detection:</label>
                             <select id="upscale-edge-algo" style="width: 100%; padding: 5px; margin-top: 5px;">
                                 <option value="sobel" selected>Sobel</option>
                                 <option value="prewitt">Prewitt</option>
                                 <option value="canny">Canny</option>
                             </select>
                        </div>
                        
                        <div class="upscale-control-group visible" id="group-strength">
                            <div class="slider-input-group">
                                <label for="upscale-strength" id="label-strength">Sharpen:</label>
                                <input type="range" id="upscale-strength" min="0" max="50" value="5">
                                <input type="number" id="upscale-strength-num" value="5" min="0" max="50">
                            </div>
                        </div>

                        <div class="upscale-control-group visible" id="group-denoise">
                            <div style="margin-bottom: 10px;">
                                <label class="radio-option"><input type="checkbox" id="upscale-denoise-check"> Enable Denoise</label>
                            </div>
                            <div class="slider-input-group" id="upscale-denoise-slider-group" style="display:none;">
                                <label for="upscale-denoise">Level:</label>
                                <input type="range" id="upscale-denoise" min="0" max="20" value="2">
                                <input type="number" id="upscale-denoise-num" value="2" min="0" max="20">
                            </div>
                        </div>

                        <div class="upscale-control-group visible" id="group-blur-flat">
                            <div style="margin-bottom: 10px;">
                                <label class="radio-option"><input type="checkbox" id="upscale-blur-flat-check"> Blur Flat Areas</label>
                            </div>
                            <div class="slider-input-group" id="upscale-blur-flat-slider-group" style="display:none;">
                                <label for="upscale-blur-flat">Blur:</label>
                                <input type="range" id="upscale-blur-flat" min="0" max="10" value="2">
                                <input type="number" id="upscale-blur-flat-num" value="2" min="0" max="10">
                            </div>
                        </div>

                        <div class="upscale-control-group" id="group-detail">
                            <div class="slider-input-group">
                                <label for="upscale-detail">Detail:</label>
                                <input type="range" id="upscale-detail" min="0" max="100" value="2">
                                <input type="number" id="upscale-detail-num" value="2" min="0" max="100">
                            </div>
                        </div>

                        <div class="upscale-control-group" id="group-saturation">
                            <div class="slider-input-group">
                                <label for="upscale-saturation">Vibrance:</label>
                                <input type="range" id="upscale-saturation" min="0" max="20" value="0">
                                <input type="number" id="upscale-saturation-num" value="0" min="0" max="20">
                            </div>
                        </div>
                        
                        <div class="upscale-control-group" id="group-grading">
                            <div class="slider-input-group">
                                <label for="upscale-temp">Temp:</label>
                                <input type="range" id="upscale-temp" min="-20" max="20" value="0">
                                <input type="number" id="upscale-temp-num" value="0" min="-20" max="20">
                            </div>
                             <div class="slider-input-group">
                                <label for="upscale-tint">Tint:</label>
                                <input type="range" id="upscale-tint" min="-20" max="20" value="0">
                                <input type="number" id="upscale-tint-num" value="0" min="-20" max="20">
                            </div>
                        </div>

                        <div class="upscale-control-group" id="group-experimental" style="display:none;">
                             <div class="slider-input-group">
                                <label for="upscale-edge-crisp">Edge Crispness:</label>
                                <input type="range" id="upscale-edge-crisp" min="1" max="10" value="5">
                                <input type="number" id="upscale-edge-crisp-num" value="5" min="1" max="10">
                            </div>
                             <div class="slider-input-group">
                                <label for="upscale-lowpass">Low Pass:</label>
                                <input type="range" id="upscale-lowpass" min="0" max="10" value="0">
                                <input type="number" id="upscale-lowpass-num" value="0" min="0" max="10">
                            </div>
                             <div class="slider-input-group">
                                <label for="upscale-highpass">High Pass:</label>
                                <input type="range" id="upscale-highpass" min="0" max="10" value="0">
                                <input type="number" id="upscale-highpass-num" value="0" min="0" max="10">
                            </div>
                             <div class="slider-input-group">
                                <label for="upscale-inv">Invert Pass:</label>
                                <input type="range" id="upscale-inv" min="0" max="10" value="0">
                                <input type="number" id="upscale-inv-num" value="0" min="0" max="10">
                            </div>
                        </div>
                        
                        <div class="slider-input-group" id="group-result-count">
                            <label>Results Count:</label>
                            <input type="range" id="upscale-result-count" min="1" max="5" value="1">
                            <input type="number" id="upscale-result-count-num" value="1" min="1" max="5">
                        </div>
                    </div>

                    <div class="setting-group" id="editor-settings" style="display:none;">
                        <h4>Editor</h4>
                        <div class="sub-tab-bar">
                            <button class="sub-tab-link active" data-subtab="filters">Filters</button>
                            <button class="sub-tab-link" data-subtab="settings" id="editor-settings-tab-link" style="display:none;">Settings</button>
                            <button class="sub-tab-link" data-subtab="dither">Dither</button>
                            <button class="sub-tab-link" data-subtab="adjustments">Adjustments</button>
                        </div>

                        <div id="subtab-filters" class="sub-tab-content active">
                            <div class="filter-list-box" id="editor-filter-list">
                                <button class="filter-option active" data-filter="none">None</button>
                                <button class="filter-option" data-filter="ascii">ASCII</button>
                                <button class="filter-option" data-filter="crt">CRT Shader</button>
                                <button class="filter-option" data-filter="edge">Edge Detect</button>
                                <button class="filter-option" data-filter="glitch">Glitch</button>
                                <button class="filter-option" data-filter="invert">Invert</button>
                                <button class="filter-option" data-filter="neo">Matrix / Neo</button>
                                <button class="filter-option" data-filter="noise">Noise</button>
                                <button class="filter-option" data-filter="pixelate">Pixelate</button>
                                <button class="filter-option" data-filter="posterize">Posterize</button>
                                <button class="filter-option" data-filter="rgb">RGB Pixels</button>
                                <button class="filter-option" data-filter="sepia">Sepia</button>
                                <button class="filter-option" data-filter="solarize">Solarize</button>
                                <button class="filter-option" data-filter="emboss">Emboss</button>
                                <button class="filter-option" data-filter="vignette">Vignette</button>
                                <button class="filter-option" data-filter="wes">Wes Anderson</button>
                                <button class="filter-option" data-filter="duotone">Duotone</button>
                                <button class="filter-option" data-filter="threshold">Threshold</button>
                                <button class="filter-option" data-filter="gamma">Gamma</button>
                                <button class="filter-option" data-filter="chromatic">Chromatic</button>
                            </div>
                        </div>

                        <div id="subtab-settings" class="sub-tab-content">
                            <div id="editor-dynamic-settings">
                                <div class="dynamic-setting-group" data-for="ascii">
                                    <label>ASCII Mode:</label>
                                    <select id="ascii-mode" style="width:100%; margin-bottom:10px;">
                                        <option value="color">Color</option>
                                        <option value="mono">Mono (Green/Black)</option>
                                        <option value="bw">Black & White</option>
                                    </select>
                                    <div class="slider-input-group">
                                        <label>Block Size:</label>
                                        <input type="range" id="ascii-size" min="2" max="100" value="8">
                                        <input type="number" id="ascii-size-num" value="8" min="2" max="100">
                                    </div>
                                    <label>Characters:</label>
                                    <input type="text" id="ascii-chars" value="@%#*+=-:. " style="width:100%;">
                                </div>

                                <div class="dynamic-setting-group" data-for="edge">
                                    <label>Algorithm:</label>
                                    <select id="edge-algo" style="width:100%; margin-bottom:10px;">
                                        <option value="sobel">Sobel</option>
                                        <option value="prewitt">Prewitt</option>
                                        <option value="canny">Canny</option>
                                    </select>
                                    <label class="radio-option"><input type="checkbox" id="edge-invert"> Invert Output</label>
                                    <div class="slider-input-group">
                                        <label>Sensitivity:</label>
                                        <input type="range" id="edge-sensitivity" min="1" max="20" value="5">
                                        <input type="number" id="edge-sensitivity-num" value="5" min="1" max="20">
                                    </div>
                                </div>

                                <div class="dynamic-setting-group" data-for="glitch">
                                    <label>Glitch Type:</label>
                                    <select id="glitch-type" style="width:100%; margin-bottom:10px;">
                                        <option value="rgb">RGB Shift</option>
                                        <option value="slice">Horizontal Slice</option>
                                        <option value="jitter">Jitter</option>
                                    </select>
                                    <div class="slider-input-group">
                                        <label>Amount:</label>
                                        <input type="range" id="glitch-amount" min="0" max="50" value="10">
                                        <input type="number" id="glitch-amount-num" value="10" min="0" max="50">
                                    </div>
                                    <div class="slider-input-group">
                                        <label>Seed:</label>
                                        <input type="range" id="glitch-seed" min="0" max="100" value="0">
                                        <input type="number" id="glitch-seed-num" value="0" min="0" max="100">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="pixelate">
                                     <div class="slider-input-group">
                                        <label>Block Size:</label>
                                        <input type="range" id="pixelate-size" min="2" max="64" value="8">
                                        <input type="number" id="pixelate-size-num" value="8" min="2" max="64">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="noise">
                                     <div class="slider-input-group">
                                        <label>Amount:</label>
                                        <input type="range" id="noise-amount" min="0" max="100" value="20">
                                        <input type="number" id="noise-amount-num" value="20" min="0" max="100">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="posterize">
                                     <div class="slider-input-group">
                                        <label>Levels:</label>
                                        <input type="range" id="posterize-levels" min="2" max="32" value="4">
                                        <input type="number" id="posterize-levels-num" value="4" min="2" max="32">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="solarize">
                                     <div class="slider-input-group">
                                        <label>Threshold:</label>
                                        <input type="range" id="solarize-threshold" min="0" max="255" value="128">
                                        <input type="number" id="solarize-threshold-num" value="128" min="0" max="255">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="emboss">
                                     <div class="slider-input-group">
                                        <label>Strength:</label>
                                        <input type="range" id="emboss-strength" min="0" max="100" value="100">
                                        <input type="number" id="emboss-strength-num" value="100" min="0" max="100">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="vignette">
                                     <div class="slider-input-group">
                                        <label>Amount:</label>
                                        <input type="range" id="vignette-amount" min="0" max="100" value="50">
                                        <input type="number" id="vignette-amount-num" value="50" min="0" max="100">
                                    </div>
                                     <div class="slider-input-group">
                                        <label>Size:</label>
                                        <input type="range" id="vignette-size" min="0" max="100" value="50">
                                        <input type="number" id="vignette-size-num" value="50" min="0" max="100">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="rgb">
                                     <div class="slider-input-group">
                                        <label>Offset:</label>
                                        <input type="range" id="rgb-offset" min="0" max="50" value="5">
                                        <input type="number" id="rgb-offset-num" value="5" min="0" max="50">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="sepia">
                                     <div class="slider-input-group">
                                        <label>Intensity:</label>
                                        <input type="range" id="sepia-intensity" min="0" max="100" value="100">
                                        <input type="number" id="sepia-intensity-num" value="100" min="0" max="100">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="duotone">
                                    <div class="gradient-editor">
                                        <label>Color 1:</label>
                                        <input type="color" id="duotone-color1" value="#000000">
                                    </div>
                                    <div class="gradient-editor">
                                        <label>Color 2:</label>
                                        <input type="color" id="duotone-color2" value="#ffffff">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="threshold">
                                     <div class="slider-input-group">
                                        <label>Level:</label>
                                        <input type="range" id="threshold-level" min="0" max="255" value="128">
                                        <input type="number" id="threshold-level-num" value="128" min="0" max="255">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="gamma">
                                     <div class="slider-input-group">
                                        <label>Value:</label>
                                        <input type="range" id="gamma-value" min="0.1" max="3.0" step="0.1" value="1.0">
                                        <input type="number" id="gamma-value-num" value="1.0" min="0.1" max="3.0" step="0.1">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="chromatic">
                                     <div class="slider-input-group">
                                        <label>Offset X:</label>
                                        <input type="range" id="chromatic-x" min="-20" max="20" value="5">
                                        <input type="number" id="chromatic-x-num" value="5" min="-20" max="20">
                                    </div>
                                    <div class="slider-input-group">
                                        <label>Offset Y:</label>
                                        <input type="range" id="chromatic-y" min="-20" max="20" value="0">
                                        <input type="number" id="chromatic-y-num" value="0" min="-20" max="20">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="crt">
                                     <div class="slider-input-group">
                                        <label>Scanline Intensity:</label>
                                        <input type="range" id="crt-scanline" min="0" max="100" value="50">
                                        <input type="number" id="crt-scanline-num" value="50" min="0" max="100">
                                    </div>
                                    <div class="slider-input-group">
                                        <label>Curvature:</label>
                                        <input type="range" id="crt-curvature" min="0" max="100" value="50">
                                        <input type="number" id="crt-curvature-num" value="50" min="0" max="100">
                                    </div>
                                </div>
                                
                                <div class="dynamic-setting-group" data-for="neo">
                                     <div class="slider-input-group">
                                        <label>Threshold:</label>
                                        <input type="range" id="neo-threshold" min="0" max="255" value="50">
                                        <input type="number" id="neo-threshold-num" value="50" min="0" max="255">
                                    </div>
                                </div>

                                <div class="dynamic-setting-group" data-for="common">
                                    <div class="slider-input-group">
                                        <label>Strength:</label>
                                        <input type="range" id="editor-strength" min="0" max="100" value="100">
                                        <input type="number" id="editor-strength-num" value="100" min="0" max="100">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="subtab-dither" class="sub-tab-content">
                            <label class="radio-option" style="margin-bottom:10px;">
                                <input type="checkbox" id="dither-enable"> Enable Dither
                            </label>
                            <label>Algorithm:</label>
                            <select id="dither-algo" style="width:100%; margin-bottom:10px;">
                                <option value="bayer">Bayer</option>
                                <option value="crosshatch">Crosshatch</option>
                                <option value="halftone">Halftone</option>
                                <option value="contour">Contour</option>
                                <option value="legacy">Legacy</option>
                            </select>
                            <div class="slider-input-group">
                                <label>Strength:</label>
                                <input type="range" id="dither-strength" min="0" max="400" value="100">
                                <input type="number" id="dither-strength-num" value="100" min="0" max="400">
                            </div>
                            <div class="slider-input-group">
                                <label>Pattern Size:</label>
                                <input type="range" id="dither-pattern-size" min="1" max="16" value="1">
                                <input type="number" id="dither-pattern-size-num" value="1" min="1" max="16">
                            </div>
                            <div class="slider-input-group">
                                <label>Color Levels:</label>
                                <input type="range" id="dither-levels" min="2" max="16" value="4">
                                <input type="number" id="dither-levels-num" value="4" min="2" max="16">
                            </div>
                            
                            <label>Color Map:</label>
                            <select id="dither-map" style="width:100%; margin-bottom:10px;">
                                <option value="auto">Auto</option>
                                <option value="gradient">Gradient</option>
                            </select>
                            
                            <div id="dither-gradient-controls" style="display:none;">
                                <div class="gradient-editor">
                                    <input type="color" id="dither-color1" value="#000000">
                                    <span>to</span>
                                    <input type="color" id="dither-color2" value="#ffffff">
                                </div>
                            </div>
                        </div>

                        <div id="subtab-adjustments" class="sub-tab-content">
                            <div class="slider-input-group">
                                <label>Brightness:</label>
                                <input type="range" id="adj-bright" min="-100" max="100" value="0">
                                <input type="number" id="adj-bright-num" value="0" min="-100" max="100">
                            </div>
                            <div class="slider-input-group">
                                <label>Contrast:</label>
                                <input type="range" id="adj-contrast" min="-100" max="100" value="0">
                                <input type="number" id="adj-contrast-num" value="0" min="-100" max="100">
                            </div>
                            <div class="slider-input-group">
                                <label>Saturation:</label>
                                <input type="range" id="adj-sat" min="-100" max="100" value="0">
                                <input type="number" id="adj-sat-num" value="0" min="-100" max="100">
                            </div>
                            <div class="slider-input-group">
                                <label>Hue:</label>
                                <input type="range" id="adj-hue" min="-180" max="180" value="0">
                                <input type="number" id="adj-hue-num" value="0" min="-180" max="180">
                            </div>
                            <div class="slider-input-group">
                                <label>Blur:</label>
                                <input type="range" id="adj-blur" min="0" max="20" value="0">
                                <input type="number" id="adj-blur-num" value="0" min="0" max="20">
                            </div>
                            <div class="slider-input-group">
                                <label>Sharpen:</label>
                                <input type="range" id="adj-sharp" min="0" max="20" value="0">
                                <input type="number" id="adj-sharp-num" value="0" min="0" max="20">
                            </div>
                            <div class="slider-input-group">
                                <label>Grain:</label>
                                <input type="range" id="adj-grain" min="0" max="100" value="0">
                                <input type="number" id="adj-grain-num" value="0" min="0" max="100">
                            </div>
                            <div class="slider-input-group">
                                <label>Bloom:</label>
                                <input type="range" id="adj-bloom" min="0" max="100" value="0">
                                <input type="number" id="adj-bloom-num" value="0" min="0" max="100">
                            </div>
                             <div class="slider-input-group">
                                <label>Haze:</label>
                                <input type="range" id="adj-haze" min="0" max="100" value="0">
                                <input type="number" id="adj-haze-num" value="0" min="0" max="100">
                            </div>
                        </div>
                    </div>
                </div>

                <div id="tab-brush" class="tab-content">
                    <div class="setting-group">
                        <h4>Drawing</h4>
                        <div class="slider-input-group">
                            <label for="brush-size">Size:</label>
                            <input type="range" id="brush-size" min="1" max="100" value="15">
                            <input type="number" id="brush-size-num" value="15" min="1" max="100" style="width: 50px;">
                        </div>
                        <div class="slider-input-group">
                            <label for="brush-opacity">Mask Opacity:</label>
                            <input type="range" id="brush-opacity" min="0.1" max="1.0" step="0.1" value="0.6">
                            <input type="number" id="brush-opacity-num" value="0.6" min="0.1" max="1.0" step="0.1">
                        </div>
                        <div class="setting-group">
                            <label>Brush Color:</label>
                            <div class="radio-group">
                                <label class="radio-option"><input type="radio" name="brush-color" value="white"> White</label>
                                <label class="radio-option"><input type="radio" name="brush-color" value="black"> Black</label>
                                <label class="radio-option"><input type="radio" name="brush-color" value="red"> Red</label>
                                <label class="radio-option"><input type="radio" name="brush-color" value="negative" checked> Negative</label>
                            </div>
                            <p class="desc-text">All colors add to mask. Negative visually inverts image for contrast.</p>
                        </div>
                        <div class="slider-input-group" id="tolerance-group" style="display:none;">
                            <label for="magic-tolerance">Tolerance:</label>
                            <input type="range" id="magic-tolerance" min="0" max="100" value="30">
                            <input type="number" id="magic-tolerance-num" value="30" min="0" max="100">
                        </div>
                        
                        <div class="setting-group">
                            <h4>Magnifier</h4>
                            <div class="slider-input-group">
                                <label for="magnifier-zoom">Zoom:</label>
                                <input type="range" id="magnifier-zoom" min="1" max="10" step="0.5" value="1.5">
                                <input type="number" id="magnifier-zoom-num" value="1.5" min="1" max="10" step="0.5">
                            </div>
                            <div class="slider-input-group">
                                <label for="magnifier-offset">Offset:</label>
                                <input type="range" id="magnifier-offset" min="10" max="200" step="5" value="45">
                                <input type="number" id="magnifier-offset-num" value="45" min="10" max="200" step="5">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="image-input" accept="image/*" style="display: none;">

    <script id="worker-code" type="javascript/worker">
        let cachedResizeBuffer = null;
        let cachedResizeW = 0;
        let cachedResizeH = 0;

        function applyBoxBlur(data, w, h, radius) {
            const size = w * h * 4;
            const temp = new Float32Array(size);
            const dest = new Float32Array(size);
            for (let y = 0; y < h; y++) {
                const yOff = y * w * 4;
                for (let x = 0; x < w; x++) {
                    let r = 0, g = 0, b = 0;
                    let count = 0;
                    for (let k = -radius; k <= radius; k++) {
                        const px = Math.min(w - 1, Math.max(0, x + k));
                        const off = yOff + px * 4;
                        r += data[off]; g += data[off+1]; b += data[off+2]; count++;
                    }
                    const dOff = yOff + x * 4;
                    temp[dOff] = r / count; temp[dOff+1] = g / count; temp[dOff+2] = b / count; temp[dOff+3] = data[dOff+3];
                }
            }
            for (let x = 0; x < w; x++) {
                for (let y = 0; y < h; y++) {
                    let r = 0, g = 0, b = 0;
                    let count = 0;
                    for (let k = -radius; k <= radius; k++) {
                        const py = Math.min(h - 1, Math.max(0, y + k));
                        const off = (py * w + x) * 4;
                        r += temp[off]; g += temp[off+1]; b += temp[off+2]; count++;
                    }
                    const dOff = (y * w + x) * 4;
                    dest[dOff] = r / count; dest[dOff+1] = g / count; dest[dOff+2] = b / count; dest[dOff+3] = temp[dOff+3];
                }
            }
            return dest;
        }

        function createEdgeMap(data, w, h, sensitivity, algo) {
            const edges = new Float32Array(w * h);
            const mult = 1 + (sensitivity / 2.0); 
            const smooth = applyBoxBlur(data, w, h, 1); 
            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    const i = (y * w + x) * 4;
                    const i00 = ((y-1)*w + (x-1))*4; const i01 = ((y-1)*w + x)*4; const i02 = ((y-1)*w + (x+1))*4;
                    const i10 = (y*w + (x-1))*4;                                  const i12 = (y*w + (x+1))*4;
                    const i20 = ((y+1)*w + (x-1))*4; const i21 = ((y+1)*w + x)*4; const i22 = ((y+1)*w + (x+1))*4;
                    const lum = (idx) => smooth[idx]*0.299 + smooth[idx+1]*0.587 + smooth[idx+2]*0.114;
                    let gx = 0, gy = 0;
                    if (algo === 'prewitt') {
                         gx = -lum(i00) + lum(i02) - lum(i10) + lum(i12) - lum(i20) + lum(i22);
                         gy = -lum(i00) - lum(i01) - lum(i02) + lum(i20) + lum(i21) + lum(i22);
                    } else if (algo === 'canny') {
                         gx = -lum(i00) + lum(i02) - 2*lum(i10) + 2*lum(i12) - lum(i20) + lum(i22);
                         gy = -lum(i00) - 2*lum(i01) - lum(i02) + lum(i20) + 2*lum(i21) + lum(i22);
                    } else {
                         gx = -lum(i00) + lum(i02) - 2*lum(i10) + 2*lum(i12) - lum(i20) + lum(i22);
                         gy = -lum(i00) - 2*lum(i01) - lum(i02) + lum(i20) + 2*lum(i21) + lum(i22);
                    }
                    let mag = Math.sqrt(gx*gx + gy*gy);
                    if (algo === 'canny') { if (mag > 40) mag = 255; else mag = 0; } else { mag *= mult; }
                    edges[y*w + x] = Math.min(1.0, mag / 255);
                }
            }
            return edges;
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        function lerpColor(a, b, t) {
            return {
                r: a.r + (b.r - a.r) * t,
                g: a.g + (b.g - a.g) * t,
                b: a.b + (b.b - a.b) * t
            };
        }

        function applyGaussianBlur(data, w, h, radius) {
            const size = w * h * 4;
            const dest = new Float32Array(size);
            const sigma = radius / 2;
            const kSize = Math.ceil(radius * 2) + 1;
            const kernel = new Float32Array(kSize);
            const half = Math.floor(kSize / 2);
            let sum = 0;
            for(let i=0; i<kSize; i++) {
                const x = i - half;
                kernel[i] = Math.exp(-(x*x)/(2*sigma*sigma));
                sum += kernel[i];
            }
            for(let i=0; i<kSize; i++) kernel[i] /= sum;

            const temp = new Float32Array(size);
            for (let y = 0; y < h; y++) {
                const yOff = y * w * 4;
                for (let x = 0; x < w; x++) {
                    let r = 0, g = 0, b = 0;
                    for (let k = 0; k < kSize; k++) {
                        const px = Math.min(w - 1, Math.max(0, x + k - half));
                        const off = yOff + px * 4;
                        const weight = kernel[k];
                        r += data[off] * weight;
                        g += data[off+1] * weight;
                        b += data[off+2] * weight;
                    }
                    const dOff = yOff + x * 4;
                    temp[dOff] = r; temp[dOff+1] = g; temp[dOff+2] = b; temp[dOff+3] = data[dOff+3];
                }
            }
            for (let x = 0; x < w; x++) {
                for (let y = 0; y < h; y++) {
                    let r = 0, g = 0, b = 0;
                    for (let k = 0; k < kSize; k++) {
                        const py = Math.min(h - 1, Math.max(0, y + k - half));
                        const off = (py * w + x) * 4;
                        const weight = kernel[k];
                        r += temp[off] * weight;
                        g += temp[off+1] * weight;
                        b += temp[off+2] * weight;
                    }
                    const dOff = (y * w + x) * 4;
                    dest[dOff] = r; dest[dOff+1] = g; dest[dOff+2] = b; dest[dOff+3] = temp[dOff+3];
                }
            }
            return dest;
        }

        self.onmessage = function(e) {
            const { command, imageData, maskData, options } = e.data;
            try {
                if (command === 'inpaint') {
                    cachedResizeBuffer = null; 
                    processInpaintSmart(imageData, maskData, options);
                }
                else if (command === 'upscale') processUpscaleSmart(imageData, options);
                else if (command === 'editor') processEditor(imageData, options);
                else if (command === 'autolasso') processAutoLasso(imageData, options);
                else if (command === 'smartmask') processSmartMask(imageData, options);
            } catch (err) {
                self.postMessage({ type: 'error', message: err.message });
            }
        };

        function processSmartMask(imgData, options) {
            const w = imgData.width, h = imgData.height, poly = options.polygon; 
            let minX=w, maxX=0, minY=h, maxY=0;
            for(let p of poly) { if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; }
            const pad = 10; minX = Math.max(0, Math.floor(minX-pad)); maxX = Math.min(w-1, Math.ceil(maxX+pad)); minY = Math.max(0, Math.floor(minY-pad)); maxY = Math.min(h-1, Math.ceil(maxY+pad));
            const edges = new Float32Array(w*h); const data = imgData.data;
            for(let y=minY; y<=maxY; y++) {
                for(let x=minX; x<=maxX; x++) {
                    let gx=0, gy=0;
                    if(x>0 && x<w-1 && y>0 && y<h-1) {
                        const l=(y*w+(x-1))*4, r=(y*w+(x+1))*4, t=((y-1)*w+x)*4, b=((y+1)*w+x)*4;
                        const lumL=data[l]*0.299+data[l+1]*0.587+data[l+2]*0.114;
                        const lumR=data[r]*0.299+data[r+1]*0.587+data[r+2]*0.114;
                        const lumT=data[t]*0.299+data[t+1]*0.587+data[t+2]*0.114;
                        const lumB=data[b]*0.299+data[b+1]*0.587+data[b+2]*0.114;
                        gx=lumR-lumL; gy=lumB-lumT;
                    }
                    edges[y*w+x] = Math.sqrt(gx*gx + gy*gy);
                }
            }
            const resultMask = new Uint8Array(w*h); const threshold = 30; 
            function insidePoly(x, y, vs) {
                let inside = false;
                for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                    const xi = vs[i].x, yi = vs[i].y, xj = vs[j].x, yj = vs[j].y;
                    const intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }
            for(let y=minY; y<=maxY; y++) {
                for(let x=minX; x<=maxX; x++) {
                    if(insidePoly(x, y, poly) && edges[y*w+x] > threshold) {
                        resultMask[y*w+x] = 255;
                        if(x>0) resultMask[y*w+x-1] = 255; if(x<w-1) resultMask[y*w+x+1] = 255;
                        if(y>0) resultMask[(y-1)*w+x] = 255; if(y<h-1) resultMask[(y+1)*w+x] = 255;
                    }
                }
            }
            self.postMessage({ type: 'lasso_result', mask: resultMask, width: w, height: h });
        }

        function processAutoLasso(imgData, options) {
            const w = imgData.width, h = imgData.height, poly = options.polygon; 
            const resultMask = new Uint8Array(w * h);
            let minX=w, maxX=0, minY=h, maxY=0, cx=0, cy=0;
            for(let p of poly) { cx+=p.x; cy+=p.y; if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; }
            cx = Math.floor(cx / poly.length); cy = Math.floor(cy / poly.length);
            minX = Math.max(0, Math.floor(minX)); maxX = Math.min(w-1, Math.ceil(maxX)); minY = Math.max(0, Math.floor(minY)); maxY = Math.min(h-1, Math.ceil(maxY));
            function insidePoly(x, y, vs) {
                let inside = false;
                for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                    const xi = vs[i].x, yi = vs[i].y, xj = vs[j].x, yj = vs[j].y;
                    const intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }
            const boundarySamples = [];
            for(let i=0; i<poly.length; i++) {
                const px = Math.floor(poly[i].x), py = Math.floor(poly[i].y);
                if(px>=0 && px<w && py>=0 && py<h) {
                    const idx = (py*w+px)*4;
                    boundarySamples.push({r:imgData.data[idx], g:imgData.data[idx+1], b:imgData.data[idx+2]});
                }
            }
            function isBoundaryColor(r, g, b) {
                let minDist = Infinity;
                for(let s of boundarySamples) {
                    const d = Math.abs(r-s.r) + Math.abs(g-s.g) + Math.abs(b-s.b);
                    if(d < minDist) minDist = d;
                }
                return minDist < 40; 
            }
            const stack = [{x:cx, y:cy}]; const visited = new Uint8Array(w*h);
            if(!insidePoly(cx, cy, poly)) {
               stack.pop();
               for(let y=minY; y<=maxY; y+=5) { for(let x=minX; x<=maxX; x+=5) { if(insidePoly(x, y, poly)) { stack.push({x, y}); break; } } if(stack.length) break; }
            }
            while(stack.length) {
                const p = stack.pop(); const idx = p.y*w + p.x;
                if(visited[idx]) continue; visited[idx] = 1;
                const pIdx = idx*4; const r=imgData.data[pIdx], g=imgData.data[pIdx+1], b=imgData.data[pIdx+2];
                if (!isBoundaryColor(r,g,b)) { 
                    resultMask[idx] = 255; 
                    const neighbors = [{x:p.x-1, y:p.y}, {x:p.x+1, y:p.y}, {x:p.x, y:p.y-1}, {x:p.x, y:p.y+1}];
                    for(let n of neighbors) {
                        if(n.x>=minX && n.x<=maxX && n.y>=minY && n.y<=maxY) {
                            if(insidePoly(n.x, n.y, poly)) stack.push(n);
                        }
                    }
                }
            }
            self.postMessage({ type: 'lasso_result', mask: resultMask, width: w, height: h });
        }

        function processInpaintSmart(imgData, maskData, options) {
            const count = options.count || 3, patchRadius = Math.floor((options.patchSize || 9) / 2), effort = options.effort || 3, algo = options.algo || 'hybrid', invert = options.invert || false;
            const w = imgData.width, h = imgData.height, len = w * h;
            const srcBuffer = new Uint32Array(imgData.data.buffer);
            const mask = new Uint8Array(len); 
            let holePixelCount = 0, minX=w, maxX=0, minY=h, maxY=0;
            for(let i=0; i<len; i++) {
                const isMarked = maskData[i*4+3] > 10; const isHole = invert ? !isMarked : isMarked;
                if(isHole) {
                    mask[i] = 1; holePixelCount++;
                    const x = i%w, y=(i/w)|0;
                    if(x<minX) minX=x; if(x>maxX) maxX=x; if(y<minY) minY=y; if(y>maxY) maxY=y;
                }
            }
            if(holePixelCount === 0) { self.postMessage({type:'error', message:'No selection'}); return; }
            if(algo === 'smart_remove') {
                self.postMessage({ type: 'status', message: 'Detecting structures...' });
                const tempMask = new Uint8Array(mask); let keptPixels = 0;
                for(let y=minY; y<=maxY; y++) {
                    for(let x=minX; x<=maxX; x++) {
                        const i = y*w+x;
                        if(mask[i] === 1) {
                            let maxDiff = 0; const c = srcBuffer[i]; const r=(c&0xFF), g=((c>>8)&0xFF), b=((c>>16)&0xFF);
                            if(x<w-1) { const c2 = srcBuffer[i+1]; const r2=(c2&0xFF), g2=((c2>>8)&0xFF), b2=((c2>>16)&0xFF); maxDiff = Math.max(maxDiff, Math.abs(r-r2)+Math.abs(g-g2)+Math.abs(b-b2)); }
                            if(y<h-1) { const c2 = srcBuffer[i+w]; const r2=(c2&0xFF), g2=((c2>>8)&0xFF), b2=((c2>>16)&0xFF); maxDiff = Math.max(maxDiff, Math.abs(r-r2)+Math.abs(g-g2)+Math.abs(b-b2)); }
                            if(maxDiff < 20) tempMask[i] = 0; else keptPixels++;
                        }
                    }
                }
                if(keptPixels > 0) { for(let i=0; i<len; i++) mask[i] = tempMask[i]; holePixelCount = keptPixels; }
            }
            const dilatedMask = new Uint8Array(mask);
            for(let y=minY; y<=maxY; y++) {
                for(let x=minX; x<=maxX; x++) {
                    if(mask[y*w+x] === 1) {
                        for(let dy=-2; dy<=2; dy++) for(let dx=-2; dx<=2; dx++) {
                            const ny=y+dy, nx=x+dx; if(nx>=0 && nx<w && ny>=0 && ny<h) dilatedMask[ny*w+nx] = 1;
                        }
                    }
                }
            }
            const safeSourceMask = new Uint8Array(len); 
            const safeRadius = patchRadius + 2, PAD = Math.max(patchRadius * 2, 40);
            const sMinX = Math.max(0, minX - PAD), sMaxX = Math.min(w-1, maxX + PAD), sMinY = Math.max(0, minY - PAD), sMaxY = Math.min(h-1, maxY + PAD);
            for(let y=sMinY; y<=sMaxY; y++) {
                for(let x=sMinX; x<=sMaxX; x++) {
                    if(dilatedMask[y*w+x] === 1) {
                        for(let dy=-safeRadius; dy<=safeRadius; dy++) for(let dx=-safeRadius; dx<=safeRadius; dx++) {
                            const ny=y+dy, nx=x+dx; if(nx>=0 && nx<w && ny>=0 && ny<h) safeSourceMask[ny*w+nx] = 1;
                        }
                    }
                }
            }
            let validSources = [];
            for(let y=sMinY; y<=sMaxY; y+=4) for(let x=sMinX; x<=sMaxX; x+=4) { const idx = y*w+x; if(safeSourceMask[idx]===0) validSources.push(idx); }
            if(validSources.length < 100) { validSources = []; for(let i=0; i<len; i+=8) if(safeSourceMask[i]===0) validSources.push(i); }
            const gradientMap = new Float32Array(len);
            if(algo === 'linear') {
                for(let y=sMinY; y<=sMaxY; y++) for(let x=sMinX; x<=sMaxX; x++) {
                    const idx = y*w+x;
                    if(safeSourceMask[idx]===0) {
                        const c = srcBuffer[idx]; const lum = (c&0xFF)*0.299 + ((c>>8)&0xFF)*0.587 + ((c>>16)&0xFF)*0.114;
                        let gx=0, gy=0;
                        if(x<w-1) gx = ((srcBuffer[idx+1]&0xFF)*0.299) - lum; if(y<h-1) gy = ((srcBuffer[idx+w]&0xFF)*0.299) - lum;
                        gradientMap[idx] = Math.sqrt(gx*gx + gy*gy);
                    }
                }
            }
            for(let n=0; n<count; n++) {
                self.postMessage({ type: 'status', message: `Generating ${n+1}/${count}` });
                const currentBuffer = new Uint32Array(srcBuffer); const currentMask = new Uint8Array(dilatedMask);
                let remaining = 0; for(let i=0; i<len; i++) if(currentMask[i]) remaining++;
                const totalHole = remaining; const sourceMap = new Int32Array(len).fill(-1);
                let loopSafe = 0;
                while(remaining > 0 && loopSafe++ < 10000) {
                    const contour = [];
                    for(let y=minY; y<=maxY; y++) for(let x=minX; x<=maxX; x++) {
                        const i = y*w+x;
                        if(currentMask[i] === 1) {
                            let hasKnown = false, knownCount = 0;
                            if(x>0 && currentMask[i-1]===0) { hasKnown=true; knownCount++; }
                            else if(x<w-1 && currentMask[i+1]===0) { hasKnown=true; knownCount++; }
                            else if(y>0 && currentMask[i-w]===0) { hasKnown=true; knownCount++; }
                            else if(y<h-1 && currentMask[i+w]===0) { hasKnown=true; knownCount++; }
                            if(hasKnown) contour.push({i, x, y, knownCount});
                        }
                    }
                    if(contour.length === 0) break; 
                    if (algo === 'linear') contour.sort((a,b) => b.knownCount - a.knownCount);
                    else if (algo === 'pattern') { if(Math.random() > 0.5) contour.sort(() => Math.random()-0.5); }
                    else contour.sort((a,b) => b.knownCount - a.knownCount);
                    const batchSize = Math.min(contour.length, Math.max(10, contour.length/10));
                    for(let b=0; b<batchSize; b++) {
                        const target = contour[b], tIdx = target.i;
                        if(currentMask[tIdx] === 0) continue; 
                        let bestSrc = -1, minErr = Infinity; const candidates = [];
                        if(target.x > 0 && currentMask[tIdx-1] === 0 && sourceMap[tIdx-1] !== -1) { const s = sourceMap[tIdx-1] + 1; if(safeSourceMask[s] === 0) candidates.push(s); }
                        if(target.y > 0 && currentMask[tIdx-w] === 0 && sourceMap[tIdx-w] !== -1) { const s = sourceMap[tIdx-w] + w; if(safeSourceMask[s] === 0) candidates.push(s); }
                        if(target.x < w-1 && currentMask[tIdx+1] === 0 && sourceMap[tIdx+1] !== -1) { const s = sourceMap[tIdx+1] - 1; if(safeSourceMask[s] === 0) candidates.push(s); }
                        const rndAttempts = (algo === 'linear') ? 20 : (10 * effort);
                        for(let k=0; k<rndAttempts; k++) candidates.push(validSources[Math.floor(Math.random()*validSources.length)]);
                        for(let srcIdx of candidates) {
                            if(srcIdx < 0 || srcIdx >= len || safeSourceMask[srcIdx] === 1) continue;
                            const sx = srcIdx % w, sy = (srcIdx / w)|0;
                            const distSq = Math.pow(target.x - sx, 2) + Math.pow(target.y - sy, 2);
                            if(distSq < Math.pow(patchRadius * 3, 2)) continue;
                            let err = 0, countPx = 0; const distPenalty = Math.sqrt(distSq) * 0.05; 
                            for(let dy=-patchRadius; dy<=patchRadius; dy++) for(let dx=-patchRadius; dx<=patchRadius; dx++) {
                                const ty = target.y+dy, tx = target.x+dx;
                                if(tx>=0 && tx<w && ty>=0 && ty<h) {
                                    const pTIdx = ty*w+tx;
                                    if(currentMask[pTIdx] === 0) {
                                        const spy = sy+dy, spx = sx+dx;
                                        if(spx>=0 && spx<w && spy>=0 && spy<h) {
                                            const pSIdx = spy*w+spx;
                                            const valT = currentBuffer[pTIdx], valS = currentBuffer[pSIdx];
                                            const dr = (valT&0xFF) - (valS&0xFF), dg = ((valT>>8)&0xFF) - ((valS>>8)&0xFF), db = ((valT>>16)&0xFF) - ((valS>>16)&0xFF);
                                            let pixelErr = dr*dr + dg*dg + db*db;
                                            if(algo === 'linear' && gradientMap[pSIdx] < 10) pixelErr *= 2; 
                                            err += pixelErr; countPx++;
                                        } else err += 100000; 
                                    }
                                }
                            }
                            if(countPx > 0) {
                                const meanErr = (err / countPx) + distPenalty;
                                const bias = (algo === 'pattern' && candidates.indexOf(srcIdx) < 2) ? 0.1 : 1.0;
                                if(meanErr * bias < minErr) { minErr = meanErr * bias; bestSrc = srcIdx; }
                            }
                        }
                        if(bestSrc !== -1) { currentBuffer[tIdx] = currentBuffer[bestSrc]; sourceMap[tIdx] = bestSrc; currentMask[tIdx] = 0; remaining--; } 
                        else { currentMask[tIdx] = 0; remaining--; }
                    }
                    if(loopSafe % 20 === 0) { const prog = 1 - (remaining/totalHole); self.postMessage({ type: 'progress', message: `Filling... ${(prog*100).toFixed(0)}%` }); }
                }
                const finalBuffer = new Uint32Array(currentBuffer);
                self.postMessage({ type: 'result', buffer: finalBuffer.buffer, width: w, height: h, index: n }, [finalBuffer.buffer]);
            }
            self.postMessage({ type: 'complete' });
        }

        function processUpscaleSmart(imgData, options) {
            const scale = options.scale || 1.0, algo = options.algo || 'general', debug = options.debug || false, aa = options.aa || false;
            let strength = 5, denoiseLevel = 0, blurFlatLevel = 0, detailLevel = 2, saturationLevel = 0, edgeCrisp = 5, edgeAlgo = 'sobel', lpStrength = 0, hpStrength = 0, invStrength = 0, temp = 0, tint = 0, useDenoise = false, useBlurFlat = false, pseudo = false, wiener = false;
            if (algo === 'custom') {
                strength = options.strength; useDenoise = options.denoise > 0; denoiseLevel = options.denoise; detailLevel = options.detail; saturationLevel = options.saturation; edgeCrisp = options.edgeCrisp; edgeAlgo = options.edgeAlgo; lpStrength = options.lowpass; hpStrength = options.highpass; invStrength = options.invertpass; temp = options.temp; tint = options.tint; useBlurFlat = options.blurFlat > 0; blurFlatLevel = options.blurFlat;
                pseudo = options.pseudo; wiener = options.wiener;
            } else if (algo === 'sharp') { strength = 15; useDenoise = false; detailLevel = 30; }
            else if (algo === 'smooth') { strength = 2; useDenoise = true; denoiseLevel = 5; detailLevel = 1; useBlurFlat = true; blurFlatLevel = 3; }
            else if (algo === 'restore_color') { strength = 5; useDenoise = false; saturationLevel = 10; }
            else { strength = 5; useDenoise = false; detailLevel = 2; }
            if (options.strength !== undefined && algo !== 'custom') strength = options.strength;
            if (options.denoise !== undefined && algo !== 'custom') { denoiseLevel = options.denoise; useDenoise = denoiseLevel > 0; }
            if (options.blurFlat !== undefined && algo !== 'custom') { blurFlatLevel = options.blurFlat; useBlurFlat = blurFlatLevel > 0; }
            
            const w = imgData.width, h = imgData.height, newW = Math.floor(w * scale), newH = Math.floor(h * scale), src = new Uint8ClampedArray(imgData.data);
            function lanczos3(x) { if (x === 0) return 1; if (Math.abs(x) >= 3) return 0; return (Math.sin(Math.PI * x) / (Math.PI * x)) * (Math.sin(Math.PI * x / 3) / (Math.PI * x / 3)); }
            function resizeLanczos(src, w, h, destW, destH) {
                if (cachedResizeBuffer && cachedResizeW === destW && cachedResizeH === destH) return new Float32Array(cachedResizeBuffer);
                const temp = new Float32Array(destW * h * 4), dest = new Float32Array(destW * destH * 4), ratioW = w / destW;
                for (let x = 0; x < destW; x++) {
                    const center = (x + 0.5) * ratioW - 0.5, left = Math.floor(center - 3), right = Math.ceil(center + 3);
                    let totalWeight = 0; const weights = [];
                    for (let i = left; i <= right; i++) { const weight = lanczos3(center - i); weights.push({ idx: Math.min(w - 1, Math.max(0, i)), w: weight }); totalWeight += weight; }
                    for (let i = 0; i < weights.length; i++) weights[i].w /= totalWeight;
                    for (let y = 0; y < h; y++) {
                        let r = 0, g = 0, b = 0, a = 0; const yOff = y * w * 4;
                        for (const wgt of weights) { const off = yOff + wgt.idx * 4; r += src[off] * wgt.w; g += src[off+1] * wgt.w; b += src[off+2] * wgt.w; a += src[off+3] * wgt.w; }
                        const tOff = (y * destW + x) * 4; temp[tOff] = Math.max(0, Math.min(255, r)); temp[tOff+1] = Math.max(0, Math.min(255, g)); temp[tOff+2] = Math.max(0, Math.min(255, b)); temp[tOff+3] = a;
                    }
                }
                const ratioH = h / destH;
                for (let y = 0; y < destH; y++) {
                    if (y % 50 === 0) self.postMessage({ type: 'progress', message: `Resampling ${(y/destH*100).toFixed(0)}%` });
                    const center = (y + 0.5) * ratioH - 0.5, left = Math.floor(center - 3), right = Math.ceil(center + 3);
                    let totalWeight = 0; const weights = [];
                    for (let i = left; i <= right; i++) { const weight = lanczos3(center - i); weights.push({ idx: Math.min(h - 1, Math.max(0, i)), w: weight }); totalWeight += weight; }
                    for (let i = 0; i < weights.length; i++) weights[i].w /= totalWeight;
                    for (let x = 0; x < destW; x++) {
                        let r = 0, g = 0, b = 0, a = 0;
                        for (const wgt of weights) { const off = (wgt.idx * destW + x) * 4; r += temp[off] * wgt.w; g += temp[off+1] * wgt.w; b += temp[off+2] * wgt.w; a += temp[off+3] * wgt.w; }
                        const dOff = (y * destW + x) * 4; dest[dOff] = Math.max(0, Math.min(255, r)); dest[dOff+1] = Math.max(0, Math.min(255, g)); dest[dOff+2] = Math.max(0, Math.min(255, b)); dest[dOff+3] = a;
                    }
                }
                cachedResizeBuffer = new Float32Array(dest); cachedResizeW = destW; cachedResizeH = destH; return dest;
            }
            function applyVibranceSmart(data, amount) {
                if (amount <= 0) return;
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i+1], b = data[i+2], max = Math.max(r, g, b), min = Math.min(r, g, b), lum = (max + min) / 2;
                    const negLum = 255 - lum, boostFactor = (negLum / 255) * (amount / 10), sat = (max - min) / (max + 0.001);
                    if (sat < 0.9) { const avg = (r+g+b)/3; data[i] = Math.min(255, r + (r - avg) * boostFactor); data[i+1] = Math.min(255, g + (g - avg) * boostFactor); data[i+2] = Math.min(255, b + (b - avg) * boostFactor); }
                }
            }
            function applySmartBlur(data, w, h, radius, threshold) {
                const res = new Float32Array(data);
                for(let y=0; y<h; y++) for(let x=0; x<w; x++) {
                    const i = (y*w+x)*4; let rSum=0, gSum=0, bSum=0, weightSum=0; const r0 = data[i], g0=data[i+1], b0=data[i+2];
                    for(let ky=-radius; ky<=radius; ky++) for(let kx=-radius; kx<=radius; kx++) {
                        const ny = Math.min(h-1, Math.max(0, y+ky)), nx = Math.min(w-1, Math.max(0, x+kx)), ni = (ny*w+nx)*4;
                        const r = data[ni], g = data[ni+1], b = data[ni+2], dist = Math.abs(r-r0) + Math.abs(g-g0) + Math.abs(b-b0);
                        if (dist < threshold) { rSum += r; gSum += g; bSum += b; weightSum++; }
                    }
                    if (weightSum > 0) { res[i] = rSum / weightSum; res[i+1] = gSum / weightSum; res[i+2] = bSum / weightSum; res[i+3] = data[i+3]; }
                }
                return res;
            }
            function applyWienerFilter(data, w, h, noiseEstimate) {
                const mean = applyBoxBlur(data, w, h, 2), meanSq = applyBoxBlur(data.map(v => v*v), w, h, 2), result = new Float32Array(data.length);
                const epsilon = 1e-5;
                const safeNoiseEst = Math.max(epsilon, noiseEstimate);
                for(let i=0; i<data.length; i+=4) {
                     const varianceR = Math.max(0, meanSq[i] - mean[i]*mean[i]);
                     const varianceG = Math.max(0, meanSq[i+1] - mean[i+1]*mean[i+1]);
                     const varianceB = Math.max(0, meanSq[i+2] - mean[i+2]*mean[i+2]);
                     const kR = varianceR / (varianceR + safeNoiseEst), kG = varianceG / (varianceG + safeNoiseEst), kB = varianceB / (varianceB + safeNoiseEst);
                     result[i] = mean[i] + kR * (data[i] - mean[i]); result[i+1] = mean[i+1] + kG * (data[i+1] - mean[i+1]); result[i+2] = mean[i+2] + kB * (data[i+2] - mean[i+2]); result[i+3] = data[i+3];
                }
                return result;
            }
            function sendDebug(buffer, width, height, label) { const debugBuf = new Uint8ClampedArray(buffer); self.postMessage({ type: 'debug', buffer: debugBuf.buffer, width: width, height: height, label: label }, [debugBuf.buffer]); }
            self.postMessage({ type: 'status', message: 'Lanczos-3 Resampling...' });
            let processed = resizeLanczos(src, w, h, newW, newH);
            self.postMessage({ type: 'status', message: `Refining...` });
            let current = new Float32Array(processed);
            if(temp !== 0 || tint !== 0) {
                for (let i = 0; i < current.length; i += 4) {
                    let r = current[i], g = current[i+1], b = current[i+2]; r += temp * 2; b -= temp * 2; g += tint * 2;
                    current[i] = Math.min(255, Math.max(0, r)); current[i+1] = Math.min(255, Math.max(0, g)); current[i+2] = Math.min(255, Math.max(0, b));
                }
            }
            if (debug) sendDebug(new Uint8ClampedArray(current), newW, newH, "Resized");
            const edgeMap = createEdgeMap(current, newW, newH, edgeCrisp, edgeAlgo);
            if (debug) {
                const edgeVis = new Uint8ClampedArray(newW * newH * 4);
                for(let i=0; i<newW*newH; i++) { const val = edgeMap[i] * 255; edgeVis[i*4] = val; edgeVis[i*4+1] = val; edgeVis[i*4+2] = val; edgeVis[i*4+3] = 255; }
                const algoLabel = edgeAlgo.charAt(0).toUpperCase() + edgeAlgo.slice(1); sendDebug(edgeVis, newW, newH, `${algoLabel} Edges`);
            }
            if (useDenoise && denoiseLevel > 0) { const dThresh = denoiseLevel * 25; current = applySmartBlur(current, newW, newH, 2, dThresh); if (debug) sendDebug(new Uint8ClampedArray(current), newW, newH, "Denoised"); }
            let lpData, hpData, invData;
            if (lpStrength > 0 || hpStrength > 0 || invStrength > 0 || debug || pseudo || wiener) {
                 lpData = applyBoxBlur(current, newW, newH, 2);
                 if (debug && lpStrength > 0) sendDebug(new Uint8ClampedArray(lpData), newW, newH, "Low Pass");
                 hpData = new Float32Array(current.length); for(let i=0; i<current.length; i++) hpData[i] = current[i] - lpData[i];
                 if (debug && hpStrength > 0) {
                     const hpVis = new Uint8ClampedArray(current.length);
                     for(let i=0; i<current.length; i+=4) { hpVis[i] = Math.min(255, Math.max(0, hpData[i] + 128)); hpVis[i+1] = Math.min(255, Math.max(0, hpData[i+1] + 128)); hpVis[i+2] = Math.min(255, Math.max(0, hpData[i+2] + 128)); hpVis[i+3] = 255; }
                     sendDebug(hpVis, newW, newH, "High Pass");
                 }
                 invData = new Float32Array(current.length);
                 for(let i=0; i<current.length; i+=4) { invData[i] = 255 - current[i]; invData[i+1] = 255 - current[i+1]; invData[i+2] = 255 - current[i+2]; invData[i+3] = 255; }
                 if (debug) sendDebug(new Uint8ClampedArray(invData), newW, newH, "Inverted");
            }
            if (lpStrength > 0) { const factor = lpStrength / 10.0; for(let i=0; i<current.length; i++) current[i] = current[i]*(1-factor) + lpData[i]*factor; }
            if (hpStrength > 0) {
                 const factor = hpStrength / 2.0; for(let i=0; i<current.length; i+=4) { current[i] += hpData[i] * factor; current[i+1] += hpData[i+1] * factor; current[i+2] += hpData[i+2] * factor; }
            }
            if (wiener) {
                 const noiseEst = (denoiseLevel || 2) * 100; const wienerHp = applyWienerFilter(hpData, newW, newH, noiseEst);
                 if (debug) {
                     const wVis = new Uint8ClampedArray(current.length);
                     for(let i=0; i<current.length; i+=4) { wVis[i] = Math.min(255, Math.max(0, wienerHp[i] + 128)); wVis[i+1] = Math.min(255, Math.max(0, wienerHp[i+1] + 128)); wVis[i+2] = Math.min(255, Math.max(0, wienerHp[i+2] + 128)); wVis[i+3] = 255; }
                     sendDebug(wVis, newW, newH, "Wiener");
                 }
                 for(let i=0; i<current.length; i+=4) { current[i] += wienerHp[i] * 0.5; current[i+1] += wienerHp[i+1] * 0.5; current[i+2] += wienerHp[i+2] * 0.5; }
            }
            if (invStrength > 0 || pseudo) {
                 const factor = (pseudo ? 5 : invStrength) / 20.0; const diff = new Float32Array(current.length); for(let i=0; i<current.length; i++) diff[i] = current[i] - invData[i];
                 const wienerDiff = applyWienerFilter(diff, newW, newH, 500); 
                 for(let i=0; i<current.length; i+=4) { current[i] += wienerDiff[i] * 0.1 * factor; current[i+1] += wienerDiff[i+1] * 0.1 * factor; current[i+2] += wienerDiff[i+2] * 0.1 * factor; }
            }
            if (strength > 0 || detailLevel > 0 || useBlurFlat) {
                const strMult = (strength / 20.0) * 3.0; const dtlMult = (detailLevel / 20.0) * 2.0;
                const blurredSmall = applyBoxBlur(current, newW, newH, 1); const blurredLarge = applyBoxBlur(current, newW, newH, 4); 
                const blurredFlat = useBlurFlat ? applyBoxBlur(current, newW, newH, blurFlatLevel) : null;
                const finalPass = new Uint8ClampedArray(current.length);
                const haloLimit = 30; 
                for(let i=0; i<current.length; i+=4) {
                     const cR = current[i], cG = current[i+1], cB = current[i+2];
                     
                     let minR=cR, maxR=cR, minG=cG, maxG=cG, minB=cB, maxB=cB;
                     const y = Math.floor(i/4/newW), x = (i/4)%newW;
                     for(let ky=-1; ky<=1; ky++) {
                         for(let kx=-1; kx<=1; kx++) {
                             if(kx===0 && ky===0) continue;
                             const idx = (Math.min(newH-1, Math.max(0, y+ky))*newW + Math.min(newW-1, Math.max(0, x+kx)))*4;
                             minR = Math.min(minR, current[idx]); maxR = Math.max(maxR, current[idx]);
                             minG = Math.min(minG, current[idx+1]); maxG = Math.max(maxG, current[idx+1]);
                             minB = Math.min(minB, current[idx+2]); maxB = Math.max(maxB, current[idx+2]);
                         }
                     }

                     const fineR = cR - blurredSmall[i], fineG = cG - blurredSmall[i+1], fineB = cB - blurredSmall[i+2];
                     const detR = cR - blurredLarge[i], detG = cG - blurredLarge[i+1], detB = cB - blurredLarge[i+2];
                     const pIdx = i/4; const edgeVal = edgeMap[pIdx];
                     const noiseGate = edgeVal > 0.1 ? 1.0 : 0.0; const areaWeight = Math.max(0.1, edgeVal * 3.0);
                     let addR = (fineR * strMult * areaWeight) + (detR * dtlMult * noiseGate);
                     let addG = (fineG * strMult * areaWeight) + (detG * dtlMult * noiseGate);
                     let addB = (fineB * strMult * areaWeight) + (detB * dtlMult * noiseGate);
                     
                     let baseR = cR + addR, baseG = cG + addG, baseB = cB + addB;
                     
                     baseR = Math.max(minR - haloLimit, Math.min(maxR + haloLimit, baseR));
                     baseG = Math.max(minG - haloLimit, Math.min(maxG + haloLimit, baseG));
                     baseB = Math.max(minB - haloLimit, Math.min(maxB + haloLimit, baseB));

                     if (useBlurFlat && edgeVal < 0.1) {
                         const mix = (1.0 - (edgeVal * 10)) * 0.8; 
                         baseR = baseR * (1-mix) + blurredFlat[i] * mix; baseG = baseG * (1-mix) + blurredFlat[i+1] * mix; baseB = baseB * (1-mix) + blurredFlat[i+2] * mix;
                     }
                     finalPass[i] = Math.min(255, Math.max(0, baseR)); finalPass[i+1] = Math.min(255, Math.max(0, baseG)); finalPass[i+2] = Math.min(255, Math.max(0, baseB)); finalPass[i+3] = current[i+3];
                }
                processed = finalPass; 
            } else { processed = new Uint8ClampedArray(current); }
            
            if (aa) {
                const aaEdges = createEdgeMap(processed, newW, newH, 10, 'sobel'); 
                const aaBlur = applyGaussianBlur(processed, newW, newH, 1.0);
                for(let i=0; i<processed.length; i+=4) {
                    const edge = Math.min(1.0, aaEdges[i/4] > 0.1 ? aaEdges[i/4] * 2.0 : 0); 
                    processed[i] = processed[i]*(1-edge) + aaBlur[i]*edge;
                    processed[i+1] = processed[i+1]*(1-edge) + aaBlur[i+1]*edge;
                    processed[i+2] = processed[i+2]*(1-edge) + aaBlur[i+2]*edge;
                }
            }
            
            if (saturationLevel > 0) applyVibranceSmart(processed, saturationLevel);
            self.postMessage({ type: 'result', buffer: processed.buffer, width: newW, height: newH, index: 0 }, [processed.buffer]);
            self.postMessage({ type: 'complete' });
        }

        function processEditor(imgData, options) {
            const w = imgData.width, h = imgData.height, filter = options.filter, strength = options.strength;
            const src = new Float32Array(imgData.data);
            
            const adj = options.adjustments || {};
            if (adj.brightness || adj.contrast || adj.saturation || adj.hue || adj.blur || adj.sharp || adj.grain || adj.bloom || adj.haze) {
                const bright = (adj.brightness || 0) / 100;
                const c = ((adj.contrast || 0) + 100) / 100;
                const s = ((adj.saturation || 0) + 100) / 100;
                const hue = adj.hue || 0;
                
                if (adj.blur > 0) {
                    const blurred = applyBoxBlur(src, w, h, adj.blur);
                    for(let i=0; i<src.length; i++) src[i] = blurred[i];
                }
                if (adj.sharp > 0) {
                    const blurred = applyBoxBlur(src, w, h, 1);
                    const factor = adj.sharp / 10;
                    for(let i=0; i<src.length; i+=4) {
                        src[i] += (src[i] - blurred[i]) * factor;
                        src[i+1] += (src[i+1] - blurred[i+1]) * factor;
                        src[i+2] += (src[i+2] - blurred[i+2]) * factor;
                    }
                }
                if (adj.bloom > 0) {
                    const thresh = 200; 
                    const bloomMap = new Float32Array(src.length);
                    for(let i=0; i<src.length; i+=4) {
                         const lum = src[i]*0.299 + src[i+1]*0.587 + src[i+2]*0.114;
                         if(lum > thresh) {
                             bloomMap[i] = src[i]; bloomMap[i+1] = src[i+1]; bloomMap[i+2] = src[i+2];
                         }
                    }
                    const blurredBloom = applyBoxBlur(bloomMap, w, h, 10);
                    const bloomStr = adj.bloom / 100.0;
                    for(let i=0; i<src.length; i+=4) {
                        src[i] = Math.min(255, src[i] + blurredBloom[i] * bloomStr);
                        src[i+1] = Math.min(255, src[i+1] + blurredBloom[i+1] * bloomStr);
                        src[i+2] = Math.min(255, src[i+2] + blurredBloom[i+2] * bloomStr);
                    }
                }
                if (adj.haze > 0) {
                    const hStr = adj.haze / 100.0;
                    const hColor = 200;
                    for(let i=0; i<src.length; i+=4) {
                        src[i] = src[i] * (1-hStr) + hColor * hStr;
                        src[i+1] = src[i+1] * (1-hStr) + hColor * hStr;
                        src[i+2] = src[i+2] * (1-hStr) + hColor * hStr;
                    }
                }
                if (adj.grain > 0) {
                     const gStr = adj.grain * 0.5;
                     for(let i=0; i<src.length; i+=4) {
                         const noise = (Math.random() - 0.5) * gStr;
                         src[i] += noise; src[i+1] += noise; src[i+2] += noise;
                     }
                }

                for (let i = 0; i < src.length; i += 4) {
                    let r = src[i], g = src[i+1], b = src[i+2];
                    r = ((r/255 - 0.5) * c + 0.5) * 255 + (bright * 255);
                    g = ((g/255 - 0.5) * c + 0.5) * 255 + (bright * 255);
                    b = ((b/255 - 0.5) * c + 0.5) * 255 + (bright * 255);
                    
                    if (s !== 1) {
                        const gray = 0.299*r + 0.587*g + 0.114*b;
                        r = gray + (r - gray) * s; g = gray + (g - gray) * s; b = gray + (b - gray) * s;
                    }
                    if (hue !== 0) {
                        const cosA = Math.cos(hue * Math.PI / 180), sinA = Math.sin(hue * Math.PI / 180);
                        const neoR = r*cosA + g*sinA; const neoG = g*cosA - r*sinA; 
                        r = neoR; g = neoG; 
                    }
                    src[i] = Math.min(255, Math.max(0, r)); src[i+1] = Math.min(255, Math.max(0, g)); src[i+2] = Math.min(255, Math.max(0, b));
                }
            }

            const dest = new Uint8ClampedArray(src.length);
            const factor = strength / 50.0; 

            if (filter === 'ascii') {
                const mode = options.asciiMode || 'color';
                const blockSize = Math.max(2, options.asciiSize || 8);
                const chars = options.asciiChars || "@%#*+=-:. ";
                const canvas = new OffscreenCanvas(w, h);
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = (mode === 'mono' || mode === 'bw') ? '#000' : '#000';
                ctx.fillRect(0, 0, w, h);
                ctx.font = `${blockSize}px monospace`;
                ctx.textBaseline = 'top';
                
                for (let y = 0; y < h; y += blockSize) {
                    for (let x = 0; x < w; x += blockSize) {
                        let r=0, g=0, b=0, count=0;
                        for(let by=0; by<blockSize && y+by<h; by++) {
                            for(let bx=0; bx<blockSize && x+bx<w; bx++) {
                                const i = ((y+by)*w + (x+bx))*4; r+=src[i]; g+=src[i+1]; b+=src[i+2]; count++;
                            }
                        }
                        r/=count; g/=count; b/=count;
                        const lum = 0.299*r + 0.587*g + 0.114*b;
                        const charIdx = Math.floor((1 - (lum/255)) * (chars.length-1));
                        const char = chars[charIdx] || ' ';
                        
                        if (mode === 'color') ctx.fillStyle = `rgb(${r},${g},${b})`;
                        else if (mode === 'mono') ctx.fillStyle = `rgb(0, 255, 0)`;
                        else ctx.fillStyle = `rgb(255, 255, 255)`;
                        
                        ctx.fillText(char, x, y);
                    }
                }
                const resData = ctx.getImageData(0, 0, w, h).data;
                dest.set(resData);
            } else if (filter === 'pixelate') {
                const blockSize = Math.max(2, options.pixelateSize || 8);
                for (let y = 0; y < h; y += blockSize) {
                    for (let x = 0; x < w; x += blockSize) {
                        let r=0, g=0, b=0, count=0;
                        for(let by=0; by<blockSize && y+by<h; by++) {
                            for(let bx=0; bx<blockSize && x+bx<w; bx++) {
                                const i = ((y+by)*w + (x+bx))*4; r+=src[i]; g+=src[i+1]; b+=src[i+2]; count++;
                            }
                        }
                        r/=count; g/=count; b/=count;
                        for(let by=0; by<blockSize && y+by<h; by++) {
                            for(let bx=0; bx<blockSize && x+bx<w; bx++) {
                                const i = ((y+by)*w + (x+bx))*4; dest[i]=r; dest[i+1]=g; dest[i+2]=b; dest[i+3]=255;
                            }
                        }
                    }
                }
            } else if (filter === 'noise') {
                const amount = options.noiseAmount || 20;
                for(let i=0; i<src.length; i+=4) {
                    const n = (Math.random() - 0.5) * amount;
                    dest[i] = Math.min(255, Math.max(0, src[i] + n));
                    dest[i+1] = Math.min(255, Math.max(0, src[i+1] + n));
                    dest[i+2] = Math.min(255, Math.max(0, src[i+2] + n));
                    dest[i+3] = src[i+3];
                }
            } else if (filter === 'invert') {
                for(let i=0; i<src.length; i+=4) {
                    dest[i] = 255 - src[i]; dest[i+1] = 255 - src[i+1]; dest[i+2] = 255 - src[i+2]; dest[i+3] = src[i+3];
                }
            } else if (filter === 'sepia') {
                const intensity = (options.sepiaIntensity || 100) / 100;
                for(let i=0; i<src.length; i+=4) {
                    const r = src[i], g = src[i+1], b = src[i+2];
                    const tr = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                    const tg = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                    const tb = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                    dest[i] = r * (1-intensity) + tr * intensity;
                    dest[i+1] = g * (1-intensity) + tg * intensity;
                    dest[i+2] = b * (1-intensity) + tb * intensity;
                    dest[i+3] = src[i+3];
                }
            } else if (filter === 'wes') {
                for(let i=0; i<src.length; i+=4) {
                    let r = src[i], g = src[i+1], b = src[i+2];
                    r = Math.min(255, r * 1.1 + 10); g = Math.min(255, g * 1.0 + 10); b = Math.min(255, b * 0.9);
                    const avg = (r+g+b)/3; r = avg + (r-avg)*1.3; g = avg + (g-avg)*1.3; b = avg + (b-avg)*1.3;
                    dest[i] = Math.min(255, Math.max(0, r)); dest[i+1] = Math.min(255, Math.max(0, g)); dest[i+2] = Math.min(255, Math.max(0, b)); dest[i+3] = src[i+3];
                }
            } else if (filter === 'crt') {
                const scanInt = (options.crtScanline || 50) / 100;
                const curve = (options.crtCurvature || 50) / 100;
                for(let y=0; y<h; y++) {
                    for(let x=0; x<w; x++) {
                        const i = (y*w+x)*4;
                        const scanline = Math.sin(y * 0.5) * 0.1 * scanInt + (1 - 0.1 * scanInt);
                        const vigX = x/w - 0.5; const vigY = y/h - 0.5;
                        const vig = 1.0 - Math.sqrt(vigX*vigX + vigY*vigY) * curve;
                        let r = src[i], g = src[i+1], b = src[i+2];
                        if (x < w-2) r = src[i+4]; if (x > 2) b = src[i-4]; 
                        dest[i] = Math.min(255, r * scanline * vig); dest[i+1] = Math.min(255, g * scanline * vig); dest[i+2] = Math.min(255, b * scanline * vig); dest[i+3] = src[i+3];
                    }
                }
            } else if (filter === 'rgb') {
                const offset = options.rgbOffset || 5;
                for(let y=0; y<h; y++) {
                    for(let x=0; x<w; x++) {
                        const i = (y*w+x)*4;
                        const rIdx = (y*w + Math.min(w-1, Math.max(0, x+offset)))*4;
                        const bIdx = (y*w + Math.min(w-1, Math.max(0, x-offset)))*4;
                        dest[i] = src[rIdx]; 
                        dest[i+1] = src[i+1]; 
                        dest[i+2] = src[bIdx+2]; 
                        dest[i+3] = 255;
                    }
                }
            } else if (filter === 'neo') {
                const thresh = options.neoThreshold || 50;
                for(let i=0; i<src.length; i+=4) {
                    const lum = 0.299*src[i] + 0.587*src[i+1] + 0.114*src[i+2];
                    const val = lum < thresh ? 0 : (lum > 255-thresh ? 255 : lum);
                    dest[i] = 0; dest[i+1] = val; dest[i+2] = 0; dest[i+3] = src[i+3];
                }
            } else if (filter === 'edge') {
                 const edges = createEdgeMap(src, w, h, options.edgeSensitivity, options.edgeAlgo);
                 for(let i=0; i<w*h; i++) {
                     let val = edges[i] * 255;
                     if (options.edgeInvert) val = 255 - val;
                     dest[i*4] = val; dest[i*4+1] = val; dest[i*4+2] = val; dest[i*4+3] = 255;
                 }
            } else if (filter === 'glitch') {
                const amount = options.glitchAmount || 10;
                const seed = options.glitchSeed || 0;
                const type = options.glitchType || 'rgb';
                
                if (type === 'rgb') {
                    for(let y=0; y<h; y++) {
                        const shift = Math.floor(Math.sin(y * 0.1 + seed) * amount);
                        for(let x=0; x<w; x++) {
                            const i = (y*w+x)*4;
                            const rIdx = (y*w + Math.min(w-1, Math.max(0, x+shift)))*4;
                            const bIdx = (y*w + Math.min(w-1, Math.max(0, x-shift)))*4;
                            dest[i] = src[rIdx]; dest[i+1] = src[i+1]; dest[i+2] = src[bIdx+2]; dest[i+3] = 255;
                        }
                    }
                } else if (type === 'slice') {
                    const slices = Math.floor(h / 20);
                    for(let s=0; s<slices; s++) {
                        const yStart = Math.floor(Math.random() * h);
                        const hSlice = Math.floor(Math.random() * 20) + 1;
                        const shift = Math.floor((Math.random() - 0.5) * amount * 2);
                        if (Math.sin(s + seed) > 0) {
                            for(let y=yStart; y<Math.min(h, yStart+hSlice); y++) {
                                for(let x=0; x<w; x++) {
                                    const i = (y*w+x)*4;
                                    const sIdx = (y*w + Math.min(w-1, Math.max(0, x+shift)))*4;
                                    dest[i] = src[sIdx]; dest[i+1] = src[sIdx+1]; dest[i+2] = src[sIdx+2]; dest[i+3] = 255;
                                }
                            }
                        }
                    }
                    for(let i=0; i<src.length; i++) if(!dest[i]) dest[i] = src[i];
                } else if (type === 'jitter') {
                    for(let y=0; y<h; y++) {
                        for(let x=0; x<w; x++) {
                            const i = (y*w+x)*4;
                            if (Math.random() < 0.1) {
                                const jx = Math.floor((Math.random()-0.5)*amount);
                                const jy = Math.floor((Math.random()-0.5)*amount);
                                const idx = (Math.min(h-1, Math.max(0, y+jy))*w + Math.min(w-1, Math.max(0, x+jx)))*4;
                                dest[i] = src[idx]; dest[i+1] = src[idx+1]; dest[i+2] = src[idx+2];
                            } else {
                                dest[i] = src[i]; dest[i+1] = src[i+1]; dest[i+2] = src[i+2];
                            }
                            dest[i+3] = 255;
                        }
                    }
                }
            } else if (filter === 'solarize') {
                const thresh = options.solarizeThreshold || 128;
                for(let i=0; i<src.length; i+=4) {
                    const r = src[i], g = src[i+1], b = src[i+2];
                    dest[i] = r > thresh ? 255 - r : r;
                    dest[i+1] = g > thresh ? 255 - g : g;
                    dest[i+2] = b > thresh ? 255 - b : b;
                    dest[i+3] = src[i+3];
                }
            } else if (filter === 'emboss') {
                const str = (options.embossStrength || 100) / 100;
                const kernel = [ -2*str, -1*str, 0, -1*str, 1, 1*str, 0, 1*str, 2*str ];
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        let r = 0, g = 0, b = 0;
                        for(let ky=-1; ky<=1; ky++) {
                            for(let kx=-1; kx<=1; kx++) {
                                const px = Math.min(w-1, Math.max(0, x+kx));
                                const py = Math.min(h-1, Math.max(0, y+ky));
                                const idx = (py*w + px)*4;
                                const k = kernel[(ky+1)*3 + (kx+1)];
                                r += src[idx]*k; g += src[idx+1]*k; b += src[idx+2]*k;
                            }
                        }
                        const i = (y*w+x)*4;
                        dest[i] = Math.min(255, Math.max(0, r + 128));
                        dest[i+1] = Math.min(255, Math.max(0, g + 128));
                        dest[i+2] = Math.min(255, Math.max(0, b + 128));
                        dest[i+3] = src[i+3];
                    }
                }
            } else if (filter === 'vignette') {
                const amount = (options.vignetteAmount || 50) / 100;
                const size = (options.vignetteSize || 50) / 100;
                for(let y=0; y<h; y++) {
                    for(let x=0; x<w; x++) {
                        const i = (y*w+x)*4;
                        const dx = (x / w) - 0.5; const dy = (y / h) - 0.5;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const vig = Math.max(0, 1 - Math.max(0, dist - (0.5 - size*0.5)) * (amount * 4));
                        dest[i] = src[i] * vig; dest[i+1] = src[i+1] * vig; dest[i+2] = src[i+2] * vig; dest[i+3] = src[i+3];
                    }
                }
            } else if (filter === 'posterize') {
                const levels = Math.max(2, options.posterizeLevels || 4);
                const step = 255 / (levels - 1);
                for(let i=0; i<src.length; i+=4) {
                    dest[i] = Math.round(src[i] / step) * step;
                    dest[i+1] = Math.round(src[i+1] / step) * step;
                    dest[i+2] = Math.round(src[i+2] / step) * step;
                    dest[i+3] = src[i+3];
                }
            } else if (filter === 'duotone') {
                function hexToRgb(h){if(!h)return{r:0,g:0,b:0};const r=parseInt(h.slice(1,3),16),g=parseInt(h.slice(3,5),16),b=parseInt(h.slice(5,7),16);return{r,g,b};}
                const c1 = hexToRgb(options.ditherColor1 || '#000000'); 
                const c2 = hexToRgb(options.ditherColor2 || '#ffffff');
                for(let i=0; i<src.length; i+=4) {
                    const lum = (src[i]*0.299 + src[i+1]*0.587 + src[i+2]*0.114) / 255;
                    dest[i] = c1.r + (c2.r - c1.r) * lum;
                    dest[i+1] = c1.g + (c2.g - c1.g) * lum;
                    dest[i+2] = c1.b + (c2.b - c1.b) * lum;
                    dest[i+3] = src[i+3];
                }
            } else if (filter === 'threshold') {
                const level = options.thresholdLevel || 128;
                for(let i=0; i<src.length; i+=4) {
                    const lum = src[i]*0.299 + src[i+1]*0.587 + src[i+2]*0.114;
                    const val = lum >= level ? 255 : 0;
                    dest[i] = val; dest[i+1] = val; dest[i+2] = val; dest[i+3] = src[i+3];
                }
            } else if (filter === 'gamma') {
                const gamma = options.gammaValue || 1.0;
                const invGamma = 1.0 / gamma;
                for(let i=0; i<src.length; i+=4) {
                    dest[i] = 255 * Math.pow(src[i] / 255, invGamma);
                    dest[i+1] = 255 * Math.pow(src[i+1] / 255, invGamma);
                    dest[i+2] = 255 * Math.pow(src[i+2] / 255, invGamma);
                    dest[i+3] = src[i+3];
                }
            } else if (filter === 'chromatic') {
                const offX = options.chromaticX || 5;
                const offY = options.chromaticY || 0;
                for(let y=0; y<h; y++) {
                    for(let x=0; x<w; x++) {
                        const i = (y*w+x)*4;
                        const rX = Math.min(w-1, Math.max(0, x + offX));
                        const rY = Math.min(h-1, Math.max(0, y + offY));
                        const bX = Math.min(w-1, Math.max(0, x - offX));
                        const bY = Math.min(h-1, Math.max(0, y - offY));
                        
                        const rIdx = (rY*w + rX)*4;
                        const bIdx = (bY*w + bX)*4;
                        
                        dest[i] = src[rIdx];
                        dest[i+1] = src[i+1];
                        dest[i+2] = src[bIdx+2];
                        dest[i+3] = src[i+3];
                    }
                }
            } else {
                dest.set(src);
            }

            if (options.ditherEnable) {
                const levels = options.ditherLevels || 4;
                const algo = options.ditherAlgo || 'bayer';
                const strength = (options.ditherStrength || 25) / 100;
                const patternSize = options.ditherPatternSize || 1;
                const mapType = options.ditherMap || 'auto';
                const lM1 = levels - 1;
                
                const bayer = [ [ 0, 8, 2, 10 ], [ 12, 4, 14, 6 ], [ 3, 11, 1, 9 ], [ 15, 7, 13, 5 ] ];
                const cross = [ [ 12, 5, 6, 13 ], [ 4, 11, 10, 7 ], [ 8, 9, 3, 0 ], [ 1, 2, 15, 14 ] ];
                
                function hexToRgb(h){if(!h)return{r:0,g:0,b:0};const r=parseInt(h.slice(1,3),16),g=parseInt(h.slice(3,5),16),b=parseInt(h.slice(5,7),16);return{r,g,b};}
                function lerp(a,b,t){return a+(b-a)*t;}
                
                const col1 = options.ditherColor1 ? hexToRgb(options.ditherColor1) : {r:0,g:0,b:0};
                const col2 = options.ditherColor2 ? hexToRgb(options.ditherColor2) : {r:255,g:255,b:255};

                for(let i=0; i<dest.length; i+=4) {
                    const x = (i/4)%w; const y = Math.floor((i/4)/w);
                    const gray = 0.299*dest[i] + 0.587*dest[i+1] + 0.114*dest[i+2];
                    let threshold = 0;
                    
                    const sX = Math.floor(x / patternSize);
                    const sY = Math.floor(y / patternSize);
                    
                    if (algo === 'bayer') threshold = (bayer[sY%4][sX%4]/16 - 0.5) * (255/levels) * strength;
                    else if (algo === 'crosshatch') threshold = (cross[sY%4][sX%4]/16 - 0.5) * (255/levels) * strength;
                    else if (algo === 'halftone') {
                        const cS = 4; const hC = cS/2;
                        const d = Math.sqrt(Math.pow(sX%cS-hC, 2) + Math.pow(sY%cS-hC, 2));
                        threshold = (d - hC) * 10 * strength;
                    } else if (algo === 'contour') {
                        const stp = 255/levels;
                        threshold = Math.sin(sY * 0.2 * strength + gray/(stp*1.5)) * (stp/2);
                    } else if (algo === 'legacy') {
                        if (gray < 128) threshold = -50 * strength; else threshold = 50 * strength;
                    }

                    let val = Math.max(0, Math.min(255, gray + threshold));
                    let quant = Math.round(val / 255 * lM1) / lM1; 
                    
                    if (mapType === 'gradient') {
                        dest[i] = lerp(col1.r, col2.r, quant);
                        dest[i+1] = lerp(col1.g, col2.g, quant);
                        dest[i+2] = lerp(col1.b, col2.b, quant);
                    } else {
                        quant *= 255;
                        if (gray > 0) {
                            const adj = quant / gray;
                            dest[i] = Math.min(255, dest[i] * adj);
                            dest[i+1] = Math.min(255, dest[i+1] * adj);
                            dest[i+2] = Math.min(255, dest[i+2] * adj);
                        } else {
                            dest[i] = quant; dest[i+1] = quant; dest[i+2] = quant;
                        }
                    }
                }
            }
            
            self.postMessage({ type: 'result', buffer: dest.buffer, width: w, height: h, index: 0 }, [dest.buffer]);
            self.postMessage({ type: 'complete' });
        }
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const mainImage = document.getElementById('main-image');
            const originalImage = document.getElementById('original-image');
            const maskCanvas = document.getElementById('mask-canvas');
            const previewCanvas = document.getElementById('preview-canvas');
            const frame = document.querySelector('.frame');
            const container = document.getElementById('canvas-container');
            const ctx = maskCanvas.getContext('2d', { willReadFrequently: true });
            
            const uploadBtn = document.getElementById('upload-button');
            const runAiBtn = document.getElementById('run-ai-button');
            const runAiBtn2 = document.getElementById('run-ai-button-2');
            const upscaleLoadBtn = document.getElementById('upscale-load-preset');
            const upscaleExportBtn = document.getElementById('upscale-export-preset');
            const upscalePresetInput = document.getElementById('upscale-preset-input');
            
            const rerunBtn = document.getElementById('rerun-button');
            const confirmBtn = document.getElementById('confirm-button');
            const revertBtn = document.getElementById('revert-button');
            const advSettingsBtn = document.getElementById('advanced-settings-button');
            const imageInput = document.getElementById('image-input');
            const loadingOverlay = document.getElementById('loading-overlay');
            const statusPill = document.getElementById('status-pill');
            const advPanel = document.getElementById('advanced-settings-panel');
            const compareBtn = document.getElementById('compare-button');
            const canvasCompareBtn = document.getElementById('canvas-compare-button');
            const scaleSlider = document.getElementById('upscale-scale');
            const scaleVal = document.getElementById('upscale-scale-val');
            const resultCountSlider = document.getElementById('result-count');
            
            const algoSelect = document.getElementById('inpaint-algo');
            const algoDesc = document.getElementById('algo-desc');
            const patchSizeSlider = document.getElementById('patch-size');
            const effortSlider = document.getElementById('search-effort');
            const effortVal = document.getElementById('search-effort-val');
            const precisionDesc = document.getElementById('precision-desc');
            const invertCheck = document.getElementById('invert-mask-check');
            const debugModeCheck = document.getElementById('debug-mode-check');

            const upscaleAlgoSelect = document.getElementById('upscale-algo');
            const upscaleAlgoDesc = document.getElementById('upscale-algo-desc');
            const upscaleResultCountSlider = document.getElementById('upscale-result-count');
            const upscaleStrengthSlider = document.getElementById('upscale-strength');
            const upscaleStrengthLabel = document.getElementById('label-strength');
            const upscaleDenoiseSlider = document.getElementById('upscale-denoise');
            const upscaleDenoiseCheck = document.getElementById('upscale-denoise-check');
            const upscaleBlurFlatSlider = document.getElementById('upscale-blur-flat');
            const upscaleBlurFlatCheck = document.getElementById('upscale-blur-flat-check');
            const upscaleDetailSlider = document.getElementById('upscale-detail');
            const upscaleSaturationSlider = document.getElementById('upscale-saturation');
            const upscaleExperimentalCheck = document.getElementById('upscale-experimental');
            const upscalePseudoCheck = document.getElementById('upscale-pseudo');
            const upscaleWienerCheck = document.getElementById('upscale-wiener');
            const upscaleAACheck = document.getElementById('upscale-aa');
            const upscaleEdgeCrispSlider = document.getElementById('upscale-edge-crisp');
            const upscaleEdgeAlgoSelect = document.getElementById('upscale-edge-algo');
            const upscaleLowPassSlider = document.getElementById('upscale-lowpass');
            const upscaleHighPassSlider = document.getElementById('upscale-highpass');
            const upscaleInvPassSlider = document.getElementById('upscale-inv');
            const upscaleTempSlider = document.getElementById('upscale-temp');
            const upscaleTintSlider = document.getElementById('upscale-tint');
            
            const upscaleStandardActions = document.getElementById('upscale-standard-actions');
            const customUpscaleActions = document.getElementById('custom-upscale-actions');
            const groupResultCount = document.getElementById('group-result-count');
            const fsSaveBtn = document.getElementById('fs-save-button');

            const undoBtn = document.getElementById('undo-button');
            const redoBtn = document.getElementById('redo-button');
            const themeBtn = document.getElementById('theme-toggle-button');
            const fullscreenBtn = document.getElementById('fullscreen-button');
            const brushColorRadios = document.getElementsByName('brush-color');
            const canvasActions = document.getElementById('canvas-actions');
            const emptyStateText = document.getElementById('empty-state-text');
            const resultsBar = document.getElementById('results-bar');
            
            const modal = document.getElementById('confirm-modal');
            const modalCancel = document.getElementById('modal-cancel');
            const modalConfirm = document.getElementById('modal-confirm');
            
            const mainToolBtn = document.getElementById('main-tool-button');
            const toolPopup = document.getElementById('tool-popup');
            const toolOptions = toolPopup.querySelectorAll('button');
            const toleranceGroup = document.getElementById('tolerance-group');
            const toleranceSlider = document.getElementById('magic-tolerance');
            
            const modeEraserBtn = document.getElementById('mode-eraser');
            const modeUpscalerBtn = document.getElementById('mode-upscaler');
            const modeEditorBtn = document.getElementById('mode-editor');
            const editorFilterList = document.getElementById('editor-filter-list');
            const editorStrengthSlider = document.getElementById('editor-strength');
            
            const fsMainToolBtn = document.getElementById('fs-main-tool-button');
            const fsToolPopup = document.getElementById('fs-tool-popup');
            const fsToolOptions = fsToolPopup.querySelectorAll('button');
            const fsToolContainer = document.getElementById('fs-tool-selector-container');
            const toolSelector = document.querySelector('.controls .tool-selector-container');

            const magnifier = document.getElementById('magnifier');
            const magnifierCanvas = document.getElementById('magnifier-canvas');
            const magnifierCtx = magnifierCanvas.getContext('2d', { willReadFrequently: true });
            const magnifierCrosshair = document.getElementById('magnifier-crosshair');
            const magnifierZoomSlider = document.getElementById('magnifier-zoom');
            const magnifierOffsetSlider = document.getElementById('magnifier-offset');

            let currentTool = 'pan';
            let previousTool = 'pan';
            let isDrawing = false;
            let brushSize = 15;
            let magicTolerance = 30;
            let currentBrushColor = 'negative';
            let isProcessing = false;
            let currentMode = 'inpaint';
            
            let originalFileName = "image.png";
            let originalImageBlob = null; 
            let history = [];
            let historyStep = -1;
            let currentImageBitmap = null; 
            let originalImageBitmap = null; 
            let generatedResults = []; 
            let magicWandSeed = null;
            let lassoPoints = [];
            let lastMaskState = null; 
            let zoomScale = 1.0;
            let initialPinchDist = 0;
            let initialZoomScale = 1.0;
            let panX = 0;
            let panY = 0;
            let isPanning = false;
            let startPanX = 0;
            let startPanY = 0;
            
            let magnifierZoom = 1.5;
            let magnifierOffset = 45;
            
            let preCustomImageSrc = null; 
            let activeEditorFilter = 'none';

            const workerBlob = new Blob([document.getElementById('worker-code').textContent], { type: 'text/javascript' });
            const workerUrl = URL.createObjectURL(workerBlob);
            let worker = null;

            let isManualLayoutEnabled = false;
            let isDarkTheme = true;
            let lastWindowWidth = window.innerWidth;
            
            const resizeObserver = new ResizeObserver(() => {
                resizeCanvas();
            });
            resizeObserver.observe(resultsBar);
            resizeObserver.observe(container);

            const themes = {
                dark: {
                    '--bg-color':'#000000','--frame-color':'#ffffff','--text-color':'#ffffff','--button-bg':'#111111','--button-text':'#ffffff','--settings-bg':'#000000','--settings-outline':'#555555','--slider-track':'#555555','--slider-thumb':'#ffffff','--checkbox-color':'#333333','--number-input-bg':'#000000','--number-input-outline-color':'#555555','--glass-bg':'rgba(20, 20, 20, 0.85)','--compare-active-bg':'#ffffff','--compare-active-text':'#000000', '--accent-color': '#00ff9d', '--desc-bg': '#111111'
                },
                light: {
                    '--bg-color':'#f0f0f0','--frame-color':'#000000','--text-color':'#000000','--button-bg':'#ffffff','--button-text':'#000000','--settings-bg':'#ffffff','--settings-outline':'#cccccc','--slider-track':'#cccccc','--slider-thumb':'#000000','--checkbox-color':'#aaaaaa','--number-input-bg':'#ffffff','--number-input-outline-color':'#cccccc','--glass-bg':'rgba(255, 255, 255, 0.85)','--compare-active-bg':'#000000','--compare-active-text':'#ffffff', '--accent-color': '#009dff', '--desc-bg': '#f5f5f5'
                }
            };

            function init() {
                setupEventListeners();
                loadSettings();
                checkLayout();
                handleEmptyState();
                setTool('pan');
                updateMaskColor('negative');
                updatePrecisionDesc(3);
                updateUpscaleControlsVisibility();
                debugModeCheck.checked = true;
                
                document.querySelectorAll('input[type="range"]').forEach(range => {
                    const numInput = document.getElementById(range.id + '-num');
                    if(numInput) {
                        range.addEventListener('input', () => numInput.value = range.value);
                        numInput.addEventListener('input', () => {
                            range.value = numInput.value;
                            range.dispatchEvent(new Event('input'));
                        });
                    }
                });
                
                let animIdx = 0;
                const frames = ['( =.=)', '( >.<)', '( =.=)', '(>.< )', '(=.= )', '(>.< )', '(=.=)', '(>ᴗ<)', '(=ᴗ=)', '(>ᴗ<)', ];
                setInterval(() => {
                    document.getElementById('ascii-anim').innerText = frames[animIdx];
                    animIdx = (animIdx + 1) % frames.length;
                }, 600);
            }

            function handleEmptyState() {
                if(!mainImage.src) {
                    mainImage.style.display = 'none';
                    canvasActions.style.display = 'none';
                    emptyStateText.style.display = 'block';
                    maskCanvas.width = 300; maskCanvas.height = 300;
                    ctx.clearRect(0, 0, 300, 300);
                }
            }
            
            function downloadImage() {
                 if(!mainImage.src || mainImage.style.display === 'none') return;
                 const a = document.createElement('a');
                 a.href = mainImage.src;
                 const nameParts = originalFileName.split('.');
                 const ext = nameParts.pop();
                 const name = nameParts.join('.') + "-ae.lens." + ext;
                 a.download = name;
                 a.click();
            }

            function setupEventListeners() {
                uploadBtn.addEventListener('click', () => imageInput.click());
                imageInput.addEventListener('change', handleImageUpload);

                mainToolBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toolPopup.style.display = toolPopup.style.display === 'flex' ? 'none' : 'flex';
                });
                document.addEventListener('click', (e) => {
                    if (!mainToolBtn.contains(e.target) && !toolPopup.contains(e.target)) {
                        toolPopup.style.display = 'none';
                    }
                    if (!fsMainToolBtn.contains(e.target) && !fsToolPopup.contains(e.target)) {
                        fsToolPopup.style.display = 'none';
                    }
                });
                toolOptions.forEach(btn => {
                    btn.addEventListener('click', () => {
                        setTool(btn.dataset.tool);
                        toolPopup.style.display = 'none';
                    });
                });

                fsMainToolBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    fsToolPopup.style.display = fsToolPopup.style.display === 'flex' ? 'none' : 'flex';
                });
                fsToolOptions.forEach(btn => {
                    btn.addEventListener('click', () => {
                        setTool(btn.dataset.tool);
                        fsToolPopup.style.display = 'none';
                    });
                });

                const sizeSlider = document.getElementById('brush-size');
                const sizeNum = document.getElementById('brush-size-num');
                sizeSlider.addEventListener('input', (e) => { brushSize = parseInt(e.target.value); });
                sizeNum.addEventListener('input', (e) => { brushSize = parseInt(e.target.value); });

                document.getElementById('brush-opacity').addEventListener('input', (e) => {
                    maskCanvas.style.opacity = e.target.value;
                });
                
                scaleSlider.addEventListener('input', (e) => {
                   scaleVal.innerText = e.target.value + 'x';
                });

                upscaleDenoiseCheck.addEventListener('change', (e) => {
                    document.getElementById('upscale-denoise-slider-group').style.display = e.target.checked ? 'flex' : 'none';
                });

                upscaleBlurFlatCheck.addEventListener('change', (e) => {
                    document.getElementById('upscale-blur-flat-slider-group').style.display = e.target.checked ? 'flex' : 'none';
                });

                effortSlider.addEventListener('input', (e) => {
                    const vals = ["Low", "Low", "Med", "High", "Max"];
                    effortVal.innerText = vals[e.target.value - 1] || "Med";
                    updatePrecisionDesc(e.target.value);
                });
                
                algoSelect.addEventListener('change', (e) => {
                    const descs = {
                        'hybrid': 'Hybrid: Best for general use. Balances lines and texture.',
                        'linear': 'Linear: Prioritizes connecting lines and hard edges.',
                        'pattern': 'Pattern: Best for grass, sand, or noise. Avoids repetition.',
                        'smart_remove': 'Mesh: Optimized for removing text, fences, or thin grids.'
                    };
                    algoDesc.innerText = descs[e.target.value];
                });

                upscaleAlgoSelect.addEventListener('change', (e) => {
                    const descs = {
                        'general': 'General: Balanced enhancement, clarity, and denoising. Best for most images.',
                        'sharp': 'Sharp: Enhances edges and recovers detail. Best for medium-high res images.',
                        'smooth': 'Smooth: Reduces noise and softens artifacts. Good for old photos.',
                        'restore_color': 'Color Restore: Boosts vibrance and recovers lost color.',
                        'custom': 'Custom: Manual control over all enhancement parameters.'
                    };
                    upscaleAlgoDesc.innerText = descs[e.target.value];
                    
                    if(upscaleAlgoSelect.value === 'custom') {
                         if (!preCustomImageSrc) preCustomImageSrc = mainImage.src;
                    }
                    updateUpscaleControlsVisibility();
                });

                upscaleExperimentalCheck.addEventListener('change', updateUpscaleControlsVisibility);
                
                toleranceSlider.addEventListener('input', (e) => {
                    magicTolerance = parseInt(e.target.value);
                    if (currentTool === 'wand' && magicWandSeed) {
                         undo(); 
                         magicSelect(magicWandSeed.x, magicWandSeed.y, true); 
                         saveState();
                    }
                });
                
                brushColorRadios.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        currentBrushColor = e.target.value;
                        updateMaskColor(currentBrushColor);
                    });
                });
                
                magnifierZoomSlider.addEventListener('input', (e) => {
                    magnifierZoom = parseFloat(e.target.value);
                });

                magnifierOffsetSlider.addEventListener('input', (e) => {
                    magnifierOffset = parseInt(e.target.value);
                });

                maskCanvas.addEventListener('mousedown', startDrawing);
                maskCanvas.addEventListener('mousemove', draw);
                maskCanvas.addEventListener('mouseup', stopDrawing);
                maskCanvas.addEventListener('mouseleave', (e) => { stopDrawing(); hideMagnifier(); });
                
                maskCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrawing(e.touches[0]); });
                maskCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e.touches[0]); });
                maskCanvas.addEventListener('touchend', (e) => { stopDrawing(); hideMagnifier(); });
                maskCanvas.addEventListener('touchcancel', hideMagnifier);

                revertBtn.addEventListener('click', () => { modal.style.display = 'flex'; });
                modalCancel.addEventListener('click', () => { modal.style.display = 'none'; });
                modalConfirm.addEventListener('click', revertToOriginal);

                undoBtn.addEventListener('click', undo);
                redoBtn.addEventListener('click', redo);
                
                themeBtn.addEventListener('click', toggleTheme);
                
                fullscreenBtn.addEventListener('click', () => {
                    const isActive = frame.classList.toggle('fullscreen-active');
                    if (isActive) {
                        advPanel.style.display = 'none';
                    } else {
                        checkLayout();
                        zoomScale = 1.0;
                        panX = 0;
                        panY = 0;
                        updateZoom();
                    }
                    setTimeout(resizeCanvas, 50);
                });

                advSettingsBtn.addEventListener('click', () => {
                    advPanel.style.display = advPanel.style.display === 'none' ? 'flex' : 'none';
                });

                window.addEventListener('resize', () => {
                    if (Math.abs(window.innerWidth - lastWindowWidth) > 50) {
                        checkLayout();
                        lastWindowWidth = window.innerWidth;
                    }
                    resizeCanvas();
                });
                
                const showOriginal = () => {
                    if(originalImageBitmap) {
                        mainImage.style.opacity = '0';
                        compareBtn.classList.add('compare-active');
                        canvasCompareBtn.classList.add('compare-active');
                    }
                };
                const showResult = () => {
                   if (currentImageBitmap) {
                        mainImage.style.opacity = '1';
                        compareBtn.classList.remove('compare-active');
                        canvasCompareBtn.classList.remove('compare-active');
                   }
                };
                
                [compareBtn, canvasCompareBtn].forEach(btn => {
                    btn.addEventListener('mousedown', showOriginal);
                    btn.addEventListener('mouseup', showResult);
                    btn.addEventListener('mouseleave', showResult);
                    btn.addEventListener('touchstart', (e) => { e.preventDefault(); showOriginal(); });
                    btn.addEventListener('touchend', (e) => { e.preventDefault(); showResult(); });
                });
                
                modeEraserBtn.addEventListener('click', () => setMode('inpaint'));
                modeUpscalerBtn.addEventListener('click', () => setMode('upscale'));
                modeEditorBtn.addEventListener('click', () => setMode('editor'));

                runAiBtn.addEventListener('click', () => runProcess(false));
                runAiBtn2.addEventListener('click', () => runProcess(false));
                
                upscaleExportBtn.addEventListener('click', () => {
                    const settings = {
                        strength: upscaleStrengthSlider.value,
                        denoise: upscaleDenoiseCheck.checked ? upscaleDenoiseSlider.value : 0,
                        blurFlat: upscaleBlurFlatCheck.checked ? upscaleBlurFlatSlider.value : 0,
                        detail: upscaleDetailSlider.value,
                        saturation: upscaleSaturationSlider.value,
                        temp: upscaleTempSlider.value,
                        tint: upscaleTintSlider.value,
                        edgeCrisp: upscaleEdgeCrispSlider.value,
                        edgeAlgo: upscaleEdgeAlgoSelect.value,
                        lowpass: upscaleLowPassSlider.value,
                        highpass: upscaleHighPassSlider.value,
                        invertpass: upscaleInvPassSlider.value,
                        experimental: upscaleExperimentalCheck.checked,
                        pseudo: upscalePseudoCheck.checked,
                        wiener: upscaleWienerCheck.checked,
                        aa: upscaleAACheck.checked
                    };
                    const blob = new Blob([JSON.stringify(settings)], {type: 'application/json'});
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = 'upscale_preset.json';
                    a.click();
                });

                upscaleLoadBtn.addEventListener('click', () => {
                    upscalePresetInput.click();
                });

                upscalePresetInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (re) => {
                        try {
                            const s = JSON.parse(re.target.result);
                            upscaleStrengthSlider.value = s.strength;
                            upscaleDenoiseSlider.value = s.denoise;
                            upscaleDenoiseCheck.checked = s.denoise > 0;
                            upscaleBlurFlatSlider.value = s.blurFlat;
                            upscaleBlurFlatCheck.checked = s.blurFlat > 0;
                            upscaleDetailSlider.value = s.detail;
                            upscaleSaturationSlider.value = s.saturation;
                            upscaleTempSlider.value = s.temp;
                            upscaleTintSlider.value = s.tint;
                            upscaleEdgeCrispSlider.value = s.edgeCrisp;
                            upscaleEdgeAlgoSelect.value = s.edgeAlgo;
                            upscaleLowPassSlider.value = s.lowpass;
                            upscaleHighPassSlider.value = s.highpass;
                            upscaleInvPassSlider.value = s.invertpass;
                            upscaleExperimentalCheck.checked = s.experimental;
                            upscalePseudoCheck.checked = s.pseudo;
                            upscaleWienerCheck.checked = s.wiener;
                            upscaleAACheck.checked = s.aa;
                            
                            document.querySelectorAll('input[type="range"]').forEach(r => r.dispatchEvent(new Event('input')));
                            
                            updateUpscaleControlsVisibility();
                            runProcess(false);
                        } catch(err) {
                            alert("Invalid preset file");
                        }
                    };
                    reader.readAsText(file);
                });
                
                fsSaveBtn.addEventListener('click', downloadImage);

                rerunBtn.addEventListener('click', () => runProcess(true));
                confirmBtn.addEventListener('click', confirmResult);

                document.getElementById('export-button').addEventListener('click', downloadImage);
                
                document.querySelectorAll('.tab-link').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.tab-link').forEach(b => b.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        e.target.classList.add('active');
                        document.getElementById('tab-' + e.target.dataset.tab).classList.add('active');
                    });
                });
                
                document.querySelectorAll('.sub-tab-link').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.sub-tab-link').forEach(b => b.classList.remove('active'));
                        document.querySelectorAll('.sub-tab-content').forEach(c => c.classList.remove('active'));
                        e.target.classList.add('active');
                        document.getElementById('subtab-' + e.target.dataset.subtab).classList.add('active');
                    });
                });
                
                editorFilterList.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        editorFilterList.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        activeEditorFilter = btn.dataset.filter;
                        
                        document.querySelectorAll('.dynamic-setting-group').forEach(el => el.classList.remove('active'));
                        const specific = document.querySelector(`.dynamic-setting-group[data-for="${activeEditorFilter}"]`);
                        const common = document.querySelector(`.dynamic-setting-group[data-for="common"]`);
                        if(specific) specific.classList.add('active');
                        else if(common && activeEditorFilter !== 'none') common.classList.add('active');
                        
                        const settingsTabLink = document.getElementById('editor-settings-tab-link');
                        if (activeEditorFilter === 'none') {
                            settingsTabLink.style.display = 'none';
                            if (settingsTabLink.classList.contains('active')) {
                                document.querySelector('[data-subtab="filters"]').click();
                            }
                        } else {
                            settingsTabLink.style.display = 'block';
                        }

                        runProcess(false);
                    });
                });
                
                document.querySelectorAll('#editor-settings input, #editor-settings select').forEach(el => {
                    el.addEventListener('input', () => {
                        if(activeEditorFilter) runProcess(false);
                    });
                });
                
                document.getElementById('dither-map').addEventListener('change', (e) => {
                    document.getElementById('dither-gradient-controls').style.display = e.target.value === 'gradient' ? 'block' : 'none';
                    if(activeEditorFilter) runProcess(false);
                });

                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key.toLowerCase() === 'z') {
                        e.preventDefault();
                        if (e.shiftKey) redo(); else undo();
                    }
                    
                    if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
                    
                    if (e.key === ' ' && currentTool !== 'pan') {
                        previousTool = currentTool;
                        setTool('pan');
                    }

                    if (e.key === 'Alt') {
                        e.preventDefault();
                        showOriginal();
                    }
                    
                    switch(e.key.toLowerCase()) {
                        case 'b': setTool('brush'); break;
                        case 'l': setTool('lasso'); break;
                        case 'f': setTool('fill'); break;
                        case 'a': setTool('auto-lasso'); break;
                        case 's': setTool('wand'); break;
                        case 'e': setTool('eraser'); break;
                        case 'm': setTool('smart-mask'); break;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (e.key === ' ' && previousTool !== 'pan') {
                        setTool(previousTool);
                        previousTool = 'pan';
                    }
                    if (e.key === 'Alt') {
                        e.preventDefault();
                        showResult();
                    }
                });

                container.addEventListener('mousedown', (e) => {
                    if (frame.classList.contains('fullscreen-active')) {
                        isPanning = true;
                        startPanX = e.clientX - panX;
                        startPanY = e.clientY - panY;
                        container.style.cursor = 'grabbing';
                    }
                });
                
                container.addEventListener('mousemove', (e) => {
                    if (isPanning && frame.classList.contains('fullscreen-active')) {
                        e.preventDefault();
                        panX = e.clientX - startPanX;
                        panY = e.clientY - startPanY;
                        updateZoom();
                    }
                });
                
                container.addEventListener('mouseup', () => { isPanning = false; container.style.cursor = ''; });
                container.addEventListener('mouseleave', () => { isPanning = false; container.style.cursor = ''; });

                container.addEventListener('wheel', (e) => {
                    if (frame.classList.contains('fullscreen-active')) {
                        e.preventDefault();
                        const delta = e.deltaY * -0.001;
                        zoomScale = Math.min(Math.max(0.1, zoomScale + delta), 5);
                        updateZoom();
                    }
                });

                container.addEventListener('touchstart', (e) => {
                    if (frame.classList.contains('fullscreen-active')) {
                        if (e.touches.length === 2) {
                            e.preventDefault(); 
                            initialPinchDist = Math.hypot(
                                e.touches[0].clientX - e.touches[1].clientX,
                                e.touches[0].clientY - e.touches[1].clientY
                            );
                            initialZoomScale = zoomScale;
                        } else if (e.touches.length === 1) {
                            isPanning = true;
                            startPanX = e.touches[0].clientX - panX;
                            startPanY = e.touches[0].clientY - panY;
                        }
                    }
                }, { passive: false });

                container.addEventListener('touchmove', (e) => {
                    if (frame.classList.contains('fullscreen-active')) {
                        e.preventDefault();
                        if (e.touches.length === 2) {
                            const dist = Math.hypot(
                                e.touches[0].clientX - e.touches[1].clientX,
                                e.touches[0].clientY - e.touches[1].clientY
                            );
                            if (initialPinchDist > 0) {
                                const scale = dist / initialPinchDist;
                                zoomScale = Math.min(Math.max(0.1, initialZoomScale * scale), 5);
                                updateZoom();
                            }
                        } else if (e.touches.length === 1 && isPanning) {
                             panX = e.touches[0].clientX - startPanX;
                             panY = e.touches[0].clientY - startPanY;
                             updateZoom();
                        }
                    }
                }, { passive: false });
                
                container.addEventListener('touchend', (e) => {
                    if (e.touches.length < 2) {
                        initialPinchDist = 0;
                    }
                    if (e.touches.length === 0) isPanning = false;
                });
            }

            function updateZoom() {
                const transform = `translate(calc(-50% + ${panX}px), calc(-50% + ${panY}px)) scale(${zoomScale})`;
                mainImage.style.transform = transform;
                originalImage.style.transform = transform;
                maskCanvas.style.transform = transform;
                previewCanvas.style.transform = transform;
            }
            
            function updatePrecisionDesc(val) {
                val = parseInt(val);
                let text = "";
                let color = "var(--settings-outline)";
                switch(val) {
                    case 1: text = "Lowest fidelity. Fast scans."; color = "#ff4d4d"; break;
                    case 2: text = "Low fidelity."; color = "#ff944d"; break;
                    case 3: text = "Medium fidelity. Balanced."; color = "var(--text-color)"; break;
                    case 4: text = "High fidelity. Detailed scans."; color = "#88ff4d"; break;
                    case 5: text = "Maximum fidelity. Slowest."; color = "#00ff9d"; break;
                }
                precisionDesc.innerText = text;
                precisionDesc.style.borderLeftColor = color;
            }

            function updateUpscaleControlsVisibility() {
                const isCustom = upscaleAlgoSelect.value === 'custom';
                const isExp = upscaleExperimentalCheck.checked;
                
                upscaleStandardActions.style.display = isCustom ? 'none' : 'block';
                customUpscaleActions.style.display = isCustom ? 'flex' : 'none';
                groupResultCount.style.display = isCustom ? 'none' : 'flex';

                document.getElementById('group-strength').classList.add('visible');
                upscaleStrengthLabel.innerText = isCustom ? 'Sharpen:' : 'Sharpen:';
                
                document.getElementById('upscale-custom-options-container').style.display = isCustom ? 'block' : 'none';
                
                const otherGroups = ['group-denoise', 'group-blur-flat', 'group-detail', 'group-saturation'];
                otherGroups.forEach(id => {
                    const el = document.getElementById(id);
                    if (isCustom) el.classList.add('visible');
                    else el.classList.remove('visible');
                });

                const expEl = document.getElementById('group-experimental');
                if (isCustom && isExp) expEl.style.display = 'block';
                else expEl.style.display = 'none';
                
                const gradingEl = document.getElementById('group-grading');
                if (isCustom) gradingEl.classList.add('visible');
                else gradingEl.classList.remove('visible');
            }
            
            function updateMagnifier(x, y, clientX, clientY) {
                if (currentTool === 'pan' || !mainImage.src) {
                    hideMagnifier();
                    return;
                }
                
                magnifier.style.display = 'block';
                magnifier.style.left = `${clientX}px`;
                magnifier.style.top = `${clientY}px`;
                magnifier.style.transform = `translate(-50%, calc(-100% - ${magnifierOffset}px))`;
                
                const w = magnifierCanvas.width = 100;
                const h = magnifierCanvas.height = 100;
                
                const srcW = w / magnifierZoom;
                const srcH = h / magnifierZoom;
                
                magnifierCtx.imageSmoothingEnabled = false;
                magnifierCtx.clearRect(0, 0, w, h);
                
                magnifierCtx.drawImage(mainImage, x - srcW/2, y - srcH/2, srcW, srcH, 0, 0, w, h);
                
                const maskOpacity = parseFloat(document.getElementById('brush-opacity').value);
                magnifierCtx.globalAlpha = maskOpacity;
                magnifierCtx.drawImage(maskCanvas, x - srcW/2, y - srcH/2, srcW, srcH, 0, 0, w, h);
                magnifierCtx.globalAlpha = 1.0;
            }

            function hideMagnifier() {
                magnifier.style.display = 'none';
            }

            function setMode(mode) {
                currentMode = mode;
                const inpaintSettings = document.getElementById('inpaint-settings');
                const upscaleSettings = document.getElementById('upscale-settings');
                const editorSettings = document.getElementById('editor-settings');
                const invertOpt = document.getElementById('invert-option');
                const debugContainer = document.getElementById('debug-mode-container');
                
                modeEraserBtn.classList.remove('active');
                modeUpscalerBtn.classList.remove('active');
                modeEditorBtn.classList.remove('active');
                
                inpaintSettings.style.display = 'none';
                upscaleSettings.style.display = 'none';
                editorSettings.style.display = 'none';
                
                if (mode === 'inpaint') {
                    modeEraserBtn.classList.add('active');
                    inpaintSettings.style.display = 'block';
                    invertOpt.style.display = 'block';
                    debugContainer.style.display = 'none';
                    document.getElementById('debug-mode-check').checked = false;
                    maskCanvas.style.display = 'block';
                    setTool('brush');

                    toolSelector.style.display = 'flex'; 
                    fsToolContainer.style.display = 'block';
                    fsSaveBtn.style.display = 'none';
                } else if (mode === 'upscale') {
                    modeUpscalerBtn.classList.add('active');
                    upscaleSettings.style.display = 'block';
                    invertOpt.style.display = 'none';
                    debugContainer.style.display = 'block';
                    document.getElementById('debug-mode-check').checked = true;
                    maskCanvas.style.display = 'none';
                    setTool('pan');

                    toolSelector.style.display = 'none';
                    fsToolContainer.style.display = 'none';
                    fsSaveBtn.style.display = 'block';
                } else if (mode === 'editor') {
                    modeEditorBtn.classList.add('active');
                    editorSettings.style.display = 'block';
                    invertOpt.style.display = 'none';
                    debugContainer.style.display = 'none';
                    maskCanvas.style.display = 'none';
                    setTool('pan');
                    
                    toolSelector.style.display = 'none';
                    fsToolContainer.style.display = 'none';
                    fsSaveBtn.style.display = 'block';
                }
            }

            function setTool(tool) {
                currentTool = tool;
                const label = "Tool: " + tool.charAt(0).toUpperCase() + tool.slice(1).replace('-', ' ');
                mainToolBtn.innerText = label;
                fsMainToolBtn.innerText = label;
                
                if (tool === 'pan') {
                    maskCanvas.style.pointerEvents = 'none';
                    maskCanvas.style.cursor = 'grab';
                } else {
                    maskCanvas.style.pointerEvents = 'auto';
                    maskCanvas.style.cursor = 'crosshair';
                }
                
                if (tool === 'fill') maskCanvas.style.cursor = 'copy';
                if (tool === 'wand') maskCanvas.style.cursor = 'magic';
                if (tool === 'magic') maskCanvas.style.cursor = 'cell';
                if (tool === 'auto-lasso') maskCanvas.style.cursor = 'alias';
                if (tool === 'smart-mask') maskCanvas.style.cursor = 'crosshair';
                
                if(tool === 'wand' || tool === 'magic') {
                    toleranceGroup.style.display = 'flex';
                } else {
                    toleranceGroup.style.display = 'none';
                }
                if (tool !== 'wand') magicWandSeed = null;
            }

            function updateMaskColor(color) {
                const w = maskCanvas.width;
                const h = maskCanvas.height;
                if(w===0 || h===0) return;
                
                const imgData = ctx.getImageData(0, 0, w, h);
                const d = imgData.data;
                
                if(color === 'negative') {
                    maskCanvas.style.mixBlendMode = 'difference';
                } else {
                    maskCanvas.style.mixBlendMode = 'normal';
                }

                let r=255, g=255, b=255;
                if(color === 'black') { r=0;g=0;b=0; }
                else if(color === 'red') { r=255;g=0;b=0; }
                else if(color === 'negative') { r=255;g=255;b=255; } 
                
                for(let i=0; i<d.length; i+=4) {
                    if(d[i+3] > 0) { 
                        d[i] = r; d[i+1] = g; d[i+2] = b;
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                saveState();
            }

            async function handleImageUpload(e) {
                const file = e.target.files[0];
                if (!file) return;

                originalFileName = file.name;
                originalImageBlob = file;
                const bmp = await createImageBitmap(file);
                originalImageBitmap = bmp;
                currentImageBitmap = bmp;
                
                const url = URL.createObjectURL(file);
                compareBtn.disabled = true;
                canvasCompareBtn.disabled = true;
                
                generatedResults = [];
                resultsBar.innerHTML = '';
                resultsBar.classList.remove('active');
                rerunBtn.style.display = 'none';
                confirmBtn.style.display = 'none';
                
                mainImage.onload = () => {
                    mainImage.style.display = 'block';
                    originalImage.src = url;
                    originalImage.style.display = 'block';
                    emptyStateText.style.display = 'none';
                    canvasActions.style.display = 'flex';
                    
                    maskCanvas.width = mainImage.naturalWidth;
                    maskCanvas.height = mainImage.naturalHeight;
                    previewCanvas.width = mainImage.naturalWidth;
                    previewCanvas.height = mainImage.naturalHeight;
                    
                    resizeCanvas();
                    runAiBtn.disabled = false;
                    history = []; historyStep = -1;
                    saveState();
                };
                mainImage.src = url;
            }
            
            function revertToOriginal() {
                modal.style.display = 'none';
                if(!originalImageBitmap) return;
                
                currentImageBitmap = originalImageBitmap;
                const canvas = document.createElement('canvas');
                canvas.width = originalImageBitmap.width;
                canvas.height = originalImageBitmap.height;
                canvas.getContext('2d').drawImage(originalImageBitmap, 0,0);
                mainImage.src = canvas.toDataURL();
                
                compareBtn.disabled = true;
                canvasCompareBtn.disabled = true;
                resultsBar.classList.remove('active');
                resultsBar.innerHTML = '';
                rerunBtn.style.display = 'none';
                confirmBtn.style.display = 'none';
                
                clearMask();
                history = []; historyStep = -1; saveState();
                resizeCanvas();
                
                panX = 0; panY = 0; zoomScale = 1.0; updateZoom();
            }

            function resizeCanvas() {
                if (!mainImage.src || mainImage.style.display === 'none') return;

                const containerRect = container.getBoundingClientRect();
                const imgRatio = mainImage.naturalWidth / mainImage.naturalHeight;
                const containerRatio = containerRect.width / containerRect.height;
                
                let renderW, renderH;
                
                if (containerRatio > imgRatio) {
                    renderH = containerRect.height;
                    renderW = renderH * imgRatio;
                } else {
                    renderW = containerRect.width;
                    renderH = renderW / imgRatio;
                }

                [mainImage, originalImage, maskCanvas, previewCanvas].forEach(c => {
                    c.style.width = `${renderW}px`;
                    c.style.height = `${renderH}px`;
                    c.style.top = `50%`;
                    c.style.left = `50%`;
                    c.style.transform = `translate(calc(-50% + ${panX}px), calc(-50% + ${panY}px)) scale(${zoomScale})`;
                });
            }

            function startDrawing(e) {
                if (currentTool === 'pan') return;
                
                const {x, y, clientX, clientY} = getCoords(e);
                const intX = Math.floor(x);
                const intY = Math.floor(y);
                
                updateMagnifier(intX, intY, clientX, clientY);

                if (currentTool === 'fill') {
                    floodFillMask(intX, intY);
                    saveState();
                    return;
                }
                
                if (currentTool === 'wand') {
                    magicWandSeed = {x: intX, y: intY};
                    magicSelect(intX, intY);
                    saveState();
                    return;
                }

                isDrawing = true;
                ctx.beginPath();
                ctx.moveTo(x, y);
                
                if (currentTool === 'auto-lasso' || currentTool === 'smart-mask') {
                    lassoPoints = [{x,y}];
                } else if (currentTool === 'magic') {
                    processMagicBrush(intX, intY);
                }
            }

            function stopDrawing() {
                if (!isDrawing) return;
                isDrawing = false;
                
                if(currentTool === 'lasso') {
                    ctx.closePath();
                    setBrushStyle();
                    ctx.fill();
                    saveState();
                } else if (currentTool === 'auto-lasso') {
                    ctx.closePath();
                    runAutoLasso(lassoPoints);
                } else if (currentTool === 'smart-mask') {
                    ctx.closePath();
                    runSmartMask(lassoPoints);
                } else {
                    ctx.beginPath();
                    saveState();
                }
            }

            function runAutoLasso(points) {
                if (worker) worker.terminate();
                worker = new Worker(workerUrl);
                
                const imgData = getFullImageData();
                updateUIState(true, "Shrinking Selection...");
                
                worker.postMessage({
                    command: 'autolasso',
                    imageData: imgData,
                    options: { polygon: points }
                });
                
                worker.onmessage = (e) => {
                    if(e.data.type === 'lasso_result') {
                        applyMaskResult(e.data.mask, e.data.width, e.data.height);
                    }
                }
            }

            function runSmartMask(points) {
                if (worker) worker.terminate();
                worker = new Worker(workerUrl);
                
                const imgData = getFullImageData();
                updateUIState(true, "Detecting Edges...");
                
                worker.postMessage({
                    command: 'smartmask',
                    imageData: imgData,
                    options: { polygon: points }
                });
                
                worker.onmessage = (e) => {
                    if(e.data.type === 'lasso_result') {
                        applyMaskResult(e.data.mask, e.data.width, e.data.height);
                    }
                }
            }

            function applyMaskResult(mask, w, h) {
                ctx.clearRect(0, 0, w, h);
                const iData = ctx.createImageData(w, h);
                const d = iData.data;
                
                let r=255, g=255, b=255;
                if(currentBrushColor === 'black') { r=0;g=0;b=0; }
                else if(currentBrushColor === 'red') { r=255;g=0;b=0; }
                
                for(let i=0; i<w*h; i++) {
                    if(mask[i]) {
                        d[i*4] = r; d[i*4+1] = g; d[i*4+2] = b; d[i*4+3] = 255;
                    }
                }
                ctx.putImageData(iData, 0, 0);
                saveState();
                updateUIState(false);
            }

            function setBrushStyle() {
                ctx.globalCompositeOperation = 'source-over';
                
                if(currentBrushColor === 'black') {
                    ctx.strokeStyle = 'rgba(0,0,0,1)';
                    ctx.fillStyle = 'rgba(0,0,0,1)';
                } else if (currentBrushColor === 'red') {
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                } else {
                    ctx.strokeStyle = 'white';
                    ctx.fillStyle = 'white';
                }
                
                if(currentTool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.strokeStyle = 'rgba(0,0,0,1)';
                }
            }
            
            function draw(e) {
                if (!isDrawing) return;
                const {x, y, clientX, clientY} = getCoords(e);
                const intX = Math.floor(x);
                const intY = Math.floor(y);
                
                updateMagnifier(intX, intY, clientX, clientY);

                const rect = maskCanvas.getBoundingClientRect();
                const scaleFactor = maskCanvas.width / rect.width;
                
                ctx.lineWidth = brushSize * scaleFactor;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                setBrushStyle();

                if (currentTool === 'brush') {
                    ctx.lineTo(x, y);
                    ctx.stroke();
                } else if (currentTool === 'eraser') {
                    ctx.lineTo(x, y);
                    ctx.stroke();
                } else if (currentTool === 'lasso') {
                    ctx.lineWidth = 2 * scaleFactor;
                    ctx.lineTo(x, y);
                    ctx.stroke();
                } else if (currentTool === 'auto-lasso' || currentTool === 'smart-mask') {
                    ctx.lineWidth = 2 * scaleFactor;
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    lassoPoints.push({x,y});
                } else if (currentTool === 'magic') {
                    processMagicBrush(intX, intY);
                }
            }
            
            function getCoords(e) {
                const rect = maskCanvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                const scaleX = maskCanvas.width / rect.width;
                const scaleY = maskCanvas.height / rect.height;

                return { 
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY,
                    clientX: clientX,
                    clientY: clientY
                };
            }

            function getPixelColor(x, y) {
                const c = document.createElement('canvas');
                c.width = mainImage.naturalWidth;
                c.height = mainImage.naturalHeight;
                c.getContext('2d').drawImage(mainImage, 0, 0);
                const data = c.getContext('2d').getImageData(x, y, 1, 1).data;
                return { r: data[0], g: data[1], b: data[2] };
            }

            function getFullImageData() {
                const c = document.createElement('canvas');
                if (originalImageBitmap) {
                    c.width = originalImageBitmap.width;
                    c.height = originalImageBitmap.height;
                    c.getContext('2d').drawImage(originalImageBitmap, 0, 0);
                } else {
                    c.width = mainImage.naturalWidth;
                    c.height = mainImage.naturalHeight;
                    c.getContext('2d').drawImage(mainImage, 0, 0);
                }
                return c.getContext('2d').getImageData(0, 0, c.width, c.height);
            }

            function colorMatch(c1, c2, tolerance) {
                const diff = Math.abs(c1.r - c2.r) + Math.abs(c1.g - c2.g) + Math.abs(c1.b - c2.b);
                const maxDist = 255 * 3;
                const threshold = (tolerance / 100) * 255; 
                return diff <= threshold;
            }

            function magicSelect(startX, startY, isUpdate = false) {
                const imgData = getFullImageData();
                const w = imgData.width, h = imgData.height;
                const startIdx = (startY * w + startX) * 4;
                const startColor = { r: imgData.data[startIdx], g: imgData.data[startIdx+1], b: imgData.data[startIdx+2] };
                
                const maskImgData = ctx.getImageData(0, 0, w, h);
                const visited = new Uint8Array(w * h); 
                const stack = [startX, startY];
                const tol = magicTolerance;
                
                let r=255, g=255, b=255;
                if(currentBrushColor === 'black') { r=0;g=0;b=0; }
                else if(currentBrushColor === 'red') { r=255;g=0;b=0; }

                while(stack.length) {
                    const y = stack.pop();
                    const x = stack.pop();
                    const idx = y * w + x;
                    if(visited[idx]) continue;
                    visited[idx] = 1;
                    
                    const pIdx = idx * 4;
                    const currColor = { r: imgData.data[pIdx], g: imgData.data[pIdx+1], b: imgData.data[pIdx+2] };

                    if(colorMatch(startColor, currColor, tol)) {
                        maskImgData.data[pIdx] = r; maskImgData.data[pIdx+1] = g; maskImgData.data[pIdx+2] = b; maskImgData.data[pIdx+3] = 255;
                        if(x > 0) stack.push(x - 1, y);
                        if(x < w - 1) stack.push(x + 1, y);
                        if(y > 0) stack.push(x, y - 1);
                        if(y < h - 1) stack.push(x, y + 1);
                    }
                }
                ctx.putImageData(maskImgData, 0, 0);
            }
            
            function processMagicBrush(cx, cy) {
                const rect = maskCanvas.getBoundingClientRect();
                const scaleFactor = maskCanvas.width / rect.width;
                const radius = Math.floor(brushSize * scaleFactor / 2);
                
                const w = maskCanvas.width;
                const h = maskCanvas.height;
                
                const minX = Math.max(0, cx - radius);
                const maxX = Math.min(w, cx + radius);
                const minY = Math.max(0, cy - radius);
                const maxY = Math.min(h, cy + radius);
                
                const rw = maxX - minX;
                const rh = maxY - minY;
                
                if(rw <= 0 || rh <= 0) return;

                const c = document.createElement('canvas');
                c.width = rw; c.height = rh;
                const tempCtx = c.getContext('2d');
                tempCtx.drawImage(mainImage, minX, minY, rw, rh, 0, 0, rw, rh);
                const srcData = tempCtx.getImageData(0, 0, rw, rh).data;
                
                const maskPatch = ctx.getImageData(minX, minY, rw, rh);
                const maskD = maskPatch.data;
                
                const centerIdx = ((cy - minY) * rw + (cx - minX)) * 4;
                const refColor = { 
                    r: srcData[centerIdx], 
                    g: srcData[centerIdx+1], 
                    b: srcData[centerIdx+2] 
                };

                let r=255, g=255, b=255;
                if(currentBrushColor === 'black') { r=0;g=0;b=0; }
                else if(currentBrushColor === 'red') { r=255;g=0;b=0; }

                const rSq = radius * radius;

                for(let y=0; y<rh; y++) {
                    for(let x=0; x<rw; x++) {
                        const dx = x + minX - cx;
                        const dy = y + minY - cy;
                        
                        if(dx*dx + dy*dy <= rSq) {
                            const idx = (y * rw + x) * 4;
                            const pixColor = { r: srcData[idx], g: srcData[idx+1], b: srcData[idx+2] };
                            
                            if(colorMatch(refColor, pixColor, magicTolerance)) {
                                maskD[idx] = r; 
                                maskD[idx+1] = g; 
                                maskD[idx+2] = b; 
                                maskD[idx+3] = 255;
                            }
                        }
                    }
                }
                ctx.putImageData(maskPatch, minX, minY);
            }

            function floodFillMask(startX, startY) {
                const w = maskCanvas.width;
                const h = maskCanvas.height;
                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;
                
                const pIdx = (startY * w + startX) * 4;
                const targetAlpha = data[pIdx+3];
                
                if(targetAlpha > 0) return; 

                let r=255, g=255, b=255;
                if(currentBrushColor === 'black') { r=0;g=0;b=0; }
                else if(currentBrushColor === 'red') { r=255;g=0;b=0; }

                const stack = [startX, startY];
                
                while(stack.length) {
                    let y = stack.pop();
                    let x = stack.pop();
                    
                    let pixelPos = (y*w + x) * 4;
                    while(y-- >= 0 && data[pixelPos+3] === targetAlpha) {
                        pixelPos -= w * 4;
                    }
                    pixelPos += w * 4;
                    ++y;
                    
                    let reachLeft = false;
                    let reachRight = false;
                    
                    while(y++ < h-1 && data[pixelPos+3] === targetAlpha) {
                        data[pixelPos] = r; data[pixelPos+1] = g; data[pixelPos+2] = b; data[pixelPos+3] = 255;

                        if(x > 0) {
                            if(data[pixelPos - 4 + 3] === targetAlpha) {
                                if(!reachLeft) { stack.push(x - 1, y); reachLeft = true; }
                            } else if(reachLeft) {
                                reachLeft = false;
                            }
                        }
                        if(x < w-1) {
                            if(data[pixelPos + 4 + 3] === targetAlpha) {
                                if(!reachRight) { stack.push(x + 1, y); reachRight = true; }
                            } else if(reachRight) {
                                reachRight = false;
                            }
                        }
                        pixelPos += w * 4;
                    }
                }
                ctx.putImageData(imgData, 0, 0);
            }

            function clearMask() {
                ctx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            }

            function saveState() {
                historyStep++;
                history = history.slice(0, historyStep);
                history.push({
                    mask: maskCanvas.toDataURL(),
                    image: mainImage.src
                });
                updateHistoryButtons();
            }

            function undo() {
                if (historyStep > 0) {
                    historyStep--;
                    loadHistoryState();
                } else if (historyStep === 0) {
                     historyStep--;
                     clearMask();
                     if (mainImage.src !== originalImage.src && originalImage.src) {
                        mainImage.src = originalImage.src; 
                     }
                     updateHistoryButtons();
                }
            }

            function redo() {
                if (historyStep < history.length - 1) {
                    historyStep++;
                    loadHistoryState();
                }
            }
            
            function loadHistoryState() {
                const state = history[historyStep];
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
                    ctx.drawImage(img, 0, 0);
                    if (state.image !== mainImage.src) {
                        mainImage.src = state.image;
                        const mainImgObj = new Image();
                        mainImgObj.onload = () => {
                            createImageBitmap(mainImgObj).then(bmp => currentImageBitmap = bmp);
                        };
                        mainImgObj.src = state.image;
                    }
                    updateHistoryButtons();
                };
                img.src = state.mask;
            }
            
            function updateHistoryButtons() {
                undoBtn.disabled = historyStep < 0;
                redoBtn.disabled = historyStep >= history.length - 1;
            }

            function updateUIState(processing, msg = "Processing...") {
                isProcessing = processing;
                if(processing) {
                    frame.classList.add('processing');
                    statusPill.style.display = 'block';
                    statusPill.innerText = msg;
                    loadingOverlay.style.display = 'flex';
                    runAiBtn.innerText = "CANCEL";
                    runAiBtn.classList.add('cancel-mode');
                } else {
                    frame.classList.remove('processing');
                    statusPill.style.display = 'none';
                    loadingOverlay.style.display = 'none';
                    runAiBtn.innerText = "RUN PROCESS";
                    runAiBtn.classList.remove('cancel-mode');
                }
            }

            async function runProcess(isRerun) {
                if (isProcessing) {
                    if (worker) worker.terminate();
                    updateUIState(false);
                    return;
                }
                
                if (currentMode === 'editor' && !activeEditorFilter) return;

                updateUIState(true, currentMode === 'editor' ? "Applying Filter..." : "Initializing...");

                const imgData = getFullImageData();
                let maskData = null;

                if (currentMode === 'inpaint') {
                    if (isRerun && lastMaskState) {
                        const tempC = document.createElement('canvas');
                        tempC.width = maskCanvas.width; tempC.height = maskCanvas.height;
                        const tCtx = tempC.getContext('2d');
                        tCtx.putImageData(lastMaskState, 0, 0);
                        maskData = lastMaskState.data;
                    } else {
                        maskData = ctx.getImageData(0, 0, maskCanvas.width, maskCanvas.height).data;
                        lastMaskState = ctx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
                    }
                }

                if (worker) worker.terminate();
                worker = new Worker(workerUrl);

                if (currentMode !== 'editor') {
                    generatedResults.forEach(r => URL.revokeObjectURL(r.url));
                    generatedResults = [];
                    resultsBar.innerHTML = '';
                    resultsBar.classList.remove('active');
                }
                resizeCanvas();
                
                const isCustomUpscale = currentMode === 'upscale' && upscaleAlgoSelect.value === 'custom';
                const debugMode = debugModeCheck.checked;

                worker.onmessage = (e) => {
                    const msg = e.data;
                    if (msg.type === 'status' || msg.type === 'progress') {
                        statusPill.innerText = msg.message;
                    } else if (msg.type === 'result' || msg.type === 'debug') {
                        if (msg.type === 'debug') {
                            handleWorkerResult(msg); 
                            resultsBar.classList.add('active');
                        } 
                        
                        if (msg.type === 'result') {
                            if (isCustomUpscale || currentMode === 'editor') {
                                 const iData = new ImageData(new Uint8ClampedArray(msg.buffer), msg.width, msg.height);
                                 const tempC = document.createElement('canvas');
                                 tempC.width = msg.width;
                                 tempC.height = msg.height;
                                 tempC.getContext('2d').putImageData(iData, 0, 0);
                                 mainImage.src = tempC.toDataURL();
                            } else {
                                handleWorkerResult(msg);
                            }
                        }
                    } else if (msg.type === 'complete') {
                        updateUIState(false);
                        if (isCustomUpscale || currentMode === 'editor') {
                           // Stay in custom view
                        } else if(generatedResults.length > 0) {
                            if (!debugMode) selectResult(0); 
                            resultsBar.classList.add('active');
                            rerunBtn.style.display = 'inline-block';
                            confirmBtn.style.display = 'inline-block';
                            setTimeout(resizeCanvas, 300);
                        }
                    } else if (msg.type === 'error') {
                        alert(msg.message);
                        updateUIState(false);
                    }
                };

                const editorOptions = {};
                if (currentMode === 'editor') {
                    editorOptions.filter = activeEditorFilter;
                    editorOptions.strength = parseInt(editorStrengthSlider.value);
                    editorOptions.ditherEnable = document.getElementById('dither-enable').checked;
                    editorOptions.ditherAlgo = document.getElementById('dither-algo').value;
                    editorOptions.ditherStrength = parseInt(document.getElementById('dither-strength').value);
                    editorOptions.ditherLevels = parseInt(document.getElementById('dither-levels').value);
                    editorOptions.ditherPatternSize = parseInt(document.getElementById('dither-pattern-size').value);
                    editorOptions.ditherMap = document.getElementById('dither-map').value;
                    editorOptions.ditherColor1 = document.getElementById('dither-color1').value;
                    editorOptions.ditherColor2 = document.getElementById('dither-color2').value;
                    
                    editorOptions.adjustments = {
                        brightness: parseInt(document.getElementById('adj-bright').value),
                        contrast: parseInt(document.getElementById('adj-contrast').value),
                        saturation: parseInt(document.getElementById('adj-sat').value),
                        hue: parseInt(document.getElementById('adj-hue').value),
                        blur: parseInt(document.getElementById('adj-blur').value),
                        sharp: parseInt(document.getElementById('adj-sharp').value),
                        grain: parseInt(document.getElementById('adj-grain').value),
                        bloom: parseInt(document.getElementById('adj-bloom').value),
                        haze: parseInt(document.getElementById('adj-haze').value)
                    };

                    editorOptions.asciiMode = document.getElementById('ascii-mode').value;
                    editorOptions.asciiSize = parseInt(document.getElementById('ascii-size').value);
                    editorOptions.asciiChars = document.getElementById('ascii-chars').value;
                    
                    editorOptions.edgeAlgo = document.getElementById('edge-algo').value;
                    editorOptions.edgeInvert = document.getElementById('edge-invert').checked;
                    editorOptions.edgeSensitivity = parseInt(document.getElementById('edge-sensitivity').value);
                    
                    editorOptions.glitchType = document.getElementById('glitch-type').value;
                    editorOptions.glitchAmount = parseInt(document.getElementById('glitch-amount').value);
                    editorOptions.glitchSeed = parseInt(document.getElementById('glitch-seed').value);
                    
                    editorOptions.pixelateSize = parseInt(document.getElementById('pixelate-size').value);
                    editorOptions.noiseAmount = parseInt(document.getElementById('noise-amount').value);
                    editorOptions.posterizeLevels = parseInt(document.getElementById('posterize-levels').value);
                    
                    editorOptions.solarizeThreshold = parseInt(document.getElementById('solarize-threshold').value);
                    editorOptions.embossStrength = parseInt(document.getElementById('emboss-strength').value);
                    editorOptions.vignetteAmount = parseInt(document.getElementById('vignette-amount').value);
                    editorOptions.vignetteSize = parseInt(document.getElementById('vignette-size').value);
                    editorOptions.rgbOffset = parseInt(document.getElementById('rgb-offset').value);
                    editorOptions.sepiaIntensity = parseInt(document.getElementById('sepia-intensity').value);
                    editorOptions.thresholdLevel = parseInt(document.getElementById('threshold-level').value);
                    editorOptions.gammaValue = parseFloat(document.getElementById('gamma-value').value);
                    editorOptions.chromaticX = parseInt(document.getElementById('chromatic-x').value);
                    editorOptions.chromaticY = parseInt(document.getElementById('chromatic-y').value);
                    editorOptions.crtScanline = parseInt(document.getElementById('crt-scanline').value);
                    editorOptions.crtCurvature = parseInt(document.getElementById('crt-curvature').value);
                    editorOptions.neoThreshold = parseInt(document.getElementById('neo-threshold').value);
                    editorOptions.duotoneColor1 = document.getElementById('duotone-color1').value;
                    editorOptions.duotoneColor2 = document.getElementById('duotone-color2').value;
                }

                worker.postMessage({
                    command: currentMode,
                    imageData: imgData,
                    maskData: maskData,
                    options: {
                        count: currentMode === 'inpaint' ? parseInt(resultCountSlider.value) : 1, 
                        scale: parseFloat(scaleSlider.value),
                        algo: currentMode === 'inpaint' ? algoSelect.value : upscaleAlgoSelect.value,
                        patchSize: parseInt(patchSizeSlider.value),
                        effort: parseInt(effortSlider.value),
                        strength: parseInt(upscaleStrengthSlider.value),
                        denoise: upscaleDenoiseCheck.checked ? parseInt(upscaleDenoiseSlider.value) : 0,
                        blurFlat: upscaleBlurFlatCheck.checked ? parseInt(upscaleBlurFlatSlider.value) : 0,
                        detail: parseInt(upscaleDetailSlider.value),
                        saturation: parseInt(upscaleSaturationSlider.value),
                        edgeCrisp: parseInt(upscaleEdgeCrispSlider.value),
                        edgeAlgo: upscaleEdgeAlgoSelect.value,
                        lowpass: parseInt(upscaleLowPassSlider.value),
                        highpass: parseInt(upscaleHighPassSlider.value),
                        invertpass: upscaleInvPassSlider.value,
                        temp: parseInt(upscaleTempSlider.value),
                        tint: parseInt(upscaleTintSlider.value),
                        invert: invertCheck.checked,
                        debug: debugMode,
                        pseudo: upscalePseudoCheck.checked,
                        wiener: upscaleWienerCheck.checked,
                        aa: upscaleAACheck.checked,
                        ...editorOptions
                    }
                }, [imgData.data.buffer, maskData ? maskData.buffer : new ArrayBuffer(0)]);
            }

            function handleWorkerResult(msg) {
                const canvas = document.createElement('canvas');
                canvas.width = msg.width;
                canvas.height = msg.height;
                const ctx = canvas.getContext('2d');
                const iData = new ImageData(new Uint8ClampedArray(msg.buffer), msg.width, msg.height);
                ctx.putImageData(iData, 0, 0);

                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    generatedResults.push({ url: url, blob: blob });
                    const savedIndex = generatedResults.length - 1;
                    
                    const thumb = document.createElement('div');
                    thumb.className = 'result-thumb';
                    thumb.style.backgroundImage = `url(${url})`;
                    
                    let label = msg.label || `#${msg.index + 1}`;
                    thumb.innerHTML = `<span>${label}</span>`;
                    thumb.onclick = () => selectResult(savedIndex);
                    resultsBar.appendChild(thumb);
                    
                    if(msg.type === 'result' && msg.index === 0 && !msg.label) selectResult(savedIndex);
                });
            }

            async function selectResult(index) {
                if(!generatedResults[index]) return;
                
                document.querySelectorAll('.result-thumb').forEach((t, i) => {
                    if(i === index) t.classList.add('selected');
                    else t.classList.remove('selected');
                });

                const url = generatedResults[index].url;
                mainImage.src = url;
                currentImageBitmap = await createImageBitmap(generatedResults[index].blob);
                compareBtn.disabled = false;
                canvasCompareBtn.disabled = false;
                
                if(currentMode === 'inpaint') {
                    clearMask();
                }
                resizeCanvas();
            }
            
            function confirmResult() {
                saveState();
                resultsBar.classList.remove('active');
                resultsBar.innerHTML = '';
                generatedResults = [];
                confirmBtn.style.display = 'none';
                rerunBtn.style.display = 'none';
                clearMask();
                resizeCanvas();
            }

            function toggleManualLayout(){
                isManualLayoutEnabled = !isManualLayoutEnabled;
                checkLayout();
            }

            function checkLayout(){
                const sideBySide = isManualLayoutEnabled || window.innerWidth >= 992 || (window.innerWidth >= 480 && window.matchMedia("(orientation: landscape)").matches);
                if(sideBySide){
                    document.querySelector('.main-container').classList.add('side-by-side-layout');
                    advPanel.style.display = 'flex';
                } else {
                    document.querySelector('.main-container').classList.remove('side-by-side-layout');
                    advPanel.style.display = 'none';
                }
            }

            function toggleTheme(){
                isDarkTheme = !isDarkTheme;
                const r = document.documentElement;
                const theme = isDarkTheme ? themes.dark : themes.light;
                for(const[k,v] of Object.entries(theme)){
                    r.style.setProperty(k,v);
                }
            }

            function loadSettings(){
                 const r = document.documentElement;
                 const theme = themes.dark;
                 for(const[k,v] of Object.entries(theme)){ r.style.setProperty(k,v); }
            }
            
            init();
        });
    </script>
</body>
</html>
